<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>ES6  系列 | hello world</title>
    <meta name="description" content="hjbji">
    <link rel="stylesheet" href="/yl/assets/style.c3210e46.css">
    <link rel="modulepreload" href="/yl/assets/app.a8623452.js">
    <link rel="modulepreload" href="/yl/assets/yl_learning.md.d3490df1.lean.js">
    
    <meta name="twitter:title" content="ES6  系列 | hello world">
  <meta property="og:title" content="ES6  系列 | hello world">
  </head>
  <body>
    <div id="app"><!--[--><div class="theme"><header class="nav-bar" data-v-675d8756><div class="sidebar-button" data-v-675d8756><svg class="icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z" class></path></svg></div><a class="nav-bar-title" href="/yl/" aria-label="hello world, back to home" data-v-675d8756 data-v-cc01ef16><!----> hello world</a><div class="flex-grow" data-v-675d8756></div><div class="nav" data-v-675d8756><nav class="nav-links" data-v-675d8756 data-v-eab3edfe><!--[--><div class="item" data-v-eab3edfe><div class="nav-link" data-v-eab3edfe data-v-b8818f8c><a class="item active" href="/yl/yl/learning" data-v-b8818f8c>学习问题 <!----></a></div></div><div class="item" data-v-eab3edfe><div class="nav-dropdown-link" data-v-eab3edfe data-v-56bf3a3f><button class="button" data-v-56bf3a3f><span class="button-text" data-v-56bf3a3f>学习问题</span><span class="right button-arrow" data-v-56bf3a3f></span></button><ul class="dialog" data-v-56bf3a3f><!--[--><li class="dialog-item" data-v-56bf3a3f><div class="nav-dropdown-link-item" data-v-56bf3a3f data-v-bbc27490><a class="item active" href="/yl/yl/learning" data-v-bbc27490><span class="arrow" data-v-bbc27490></span><span class="text" data-v-bbc27490>学习问题</span><span class="icon" data-v-bbc27490><!----></span></a></div></li><li class="dialog-item" data-v-56bf3a3f><div class="nav-dropdown-link-item" data-v-56bf3a3f data-v-bbc27490><a class="item active" href="/yl/yl/learning" data-v-bbc27490><span class="arrow" data-v-bbc27490></span><span class="text" data-v-bbc27490>学习问题</span><span class="icon" data-v-bbc27490><!----></span></a></div></li><li class="dialog-item" data-v-56bf3a3f><div class="nav-dropdown-link-item" data-v-56bf3a3f data-v-bbc27490><a class="item active" href="/yl/yl/learning" data-v-bbc27490><span class="arrow" data-v-bbc27490></span><span class="text" data-v-bbc27490>学习问题</span><span class="icon" data-v-bbc27490><!----></span></a></div></li><!--]--></ul></div></div><!--]--><!----><!----></nav></div><!--[--><!--]--></header><aside class="sidebar" data-v-83e92a68><nav class="nav-links nav" data-v-83e92a68 data-v-eab3edfe><!--[--><div class="item" data-v-eab3edfe><div class="nav-link" data-v-eab3edfe data-v-b8818f8c><a class="item active" href="/yl/yl/learning" data-v-b8818f8c>学习问题 <!----></a></div></div><div class="item" data-v-eab3edfe><div class="nav-dropdown-link" data-v-eab3edfe data-v-56bf3a3f><button class="button" data-v-56bf3a3f><span class="button-text" data-v-56bf3a3f>学习问题</span><span class="right button-arrow" data-v-56bf3a3f></span></button><ul class="dialog" data-v-56bf3a3f><!--[--><li class="dialog-item" data-v-56bf3a3f><div class="nav-dropdown-link-item" data-v-56bf3a3f data-v-bbc27490><a class="item active" href="/yl/yl/learning" data-v-bbc27490><span class="arrow" data-v-bbc27490></span><span class="text" data-v-bbc27490>学习问题</span><span class="icon" data-v-bbc27490><!----></span></a></div></li><li class="dialog-item" data-v-56bf3a3f><div class="nav-dropdown-link-item" data-v-56bf3a3f data-v-bbc27490><a class="item active" href="/yl/yl/learning" data-v-bbc27490><span class="arrow" data-v-bbc27490></span><span class="text" data-v-bbc27490>学习问题</span><span class="icon" data-v-bbc27490><!----></span></a></div></li><li class="dialog-item" data-v-56bf3a3f><div class="nav-dropdown-link-item" data-v-56bf3a3f data-v-bbc27490><a class="item active" href="/yl/yl/learning" data-v-bbc27490><span class="arrow" data-v-bbc27490></span><span class="text" data-v-bbc27490>学习问题</span><span class="icon" data-v-bbc27490><!----></span></a></div></li><!--]--></ul></div></div><!--]--><!----><!----></nav><!--[--><!--]--><ul class="sidebar-links" data-v-83e92a68><!--[--><li class="sidebar-link"><p class="sidebar-link-item">learning</p><ul class="sidebar-links"><li class="sidebar-link"><a class="sidebar-link-item active" href="/yl/yl/learning">ES6</a><ul class="sidebar-links"><li class="sidebar-link"><a class="sidebar-link-item" href="#函数的扩展">函数的扩展</a><ul class="sidebar-links"><li class="sidebar-link"><a class="sidebar-link-item" href="#箭头函数">箭头函数</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="#function-prototype-tostring">Function.prototype.toString</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="#catch-命令的参数省略">catch 命令的参数省略</a><!----></li></ul></li><li class="sidebar-link"><a class="sidebar-link-item" href="#数组的扩展">数组的扩展</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="#object">Object</a><ul class="sidebar-links"><li class="sidebar-link"><a class="sidebar-link-item" href="#object-hasownproperties">Object.hasOwnProperties</a><!----></li></ul></li><li class="sidebar-link"><a class="sidebar-link-item" href="#字符串的新增方法">字符串的新增方法</a><ul class="sidebar-links"><li class="sidebar-link"><a class="sidebar-link-item" href="#padstart-padend">padStart &amp; padEnd</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="#trimstart-trimend">trimStart &amp; trimEnd</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="#includes-startswith-endswith">includes &amp; startsWith &amp; endsWith</a><!----></li></ul></li><li class="sidebar-link"><a class="sidebar-link-item" href="#set-map">Set &amp; Map</a><ul class="sidebar-links"><li class="sidebar-link"><a class="sidebar-link-item" href="#set-结构">Set 结构</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="#map-结构">Map 结构</a><!----></li></ul></li><li class="sidebar-link"><a class="sidebar-link-item" href="#promise-对象">*Promise 对象</a><ul class="sidebar-links"><li class="sidebar-link"><a class="sidebar-link-item" href="#promise-缺点">Promise 缺点</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="#promise-特点">Promise 特点</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="#promise-注意事项">Promise 注意事项</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="#promise-prototype-then">Promise.prototype.then</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="#promise-prototype-catch">Promise.prototype.catch</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="#promise-prototype-finally">Promise.prototype.finally</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="#promise-resolve">Promise.resolve</a><!----></li></ul></li><li class="sidebar-link"><a class="sidebar-link-item" href="#reflect-对象">Reflect 对象</a><ul class="sidebar-links"><li class="sidebar-link"><a class="sidebar-link-item" href="#设计目标">设计目标</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="#reflect-get">Reflect.get</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="#reflect-set">Reflect.set</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="#reflect-has">Reflect.has</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="#reflect-deleteproperty">Reflect.deleteProperty</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="#reflect-constructor">Reflect.constructor</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="#reflect-getprototypeof">Reflect.getPrototypeOf</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="#reflect-setprototypeof">Reflect.setPrototypeOf</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="#reflect-apply">Reflect.apply</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="#reflect-defineproperty">Reflect.defineProperty</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="#reflect-getownpropertydescriptor">Reflect.getOwnPropertyDescriptor</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="#reflect-isextensible">Reflect.isExtensible</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="#reflect-preventextension">Reflect.preventExtension</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="#reflect-ownkeys">Reflect.ownKeys</a><!----></li></ul></li><li class="sidebar-link"><a class="sidebar-link-item" href="#proxy">Proxy</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="#生成器-迭代器">生成器 &amp; 迭代器</a><ul class="sidebar-links"><li class="sidebar-link"><a class="sidebar-link-item" href="#for-of">for...of</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="#generator-prototype-next">Generator.prototype.next()</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="#generator-prototype-throw">Generator.prototype.throw()</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="#generator-prototype-return">Generator.prototype.return()</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="#yield">yield*</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="#作为对象属性的-generator-函数">作为对象属性的 Generator 函数</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="#generator-函数的-this">Generator 函数的 this</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="#实际应用">实际应用</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="#generator-异步">Generator 异步</a><!----></li></ul></li><li class="sidebar-link"><a class="sidebar-link-item" href="#class-类">Class 类</a><ul class="sidebar-links"><li class="sidebar-link"><a class="sidebar-link-item" href="#getter-setter">getter &amp; setter</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="#class-表达式">class 表达式</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="#静态方法-静态属性">静态方法 &amp; 静态属性</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="#实例属性的新写法">实例属性的新写法</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="#new-target">new.target</a><!----></li></ul></li><li class="sidebar-link"><a class="sidebar-link-item" href="#class-继承">Class 继承</a><ul class="sidebar-links"><li class="sidebar-link"><a class="sidebar-link-item" href="#super">super</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="#原型链">原型链</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="#类合并">类合并</a><!----></li></ul></li><li class="sidebar-link"><a class="sidebar-link-item" href="#iterator">Iterator</a><ul class="sidebar-links"><li class="sidebar-link"><a class="sidebar-link-item" href="#部署迭代器接口">部署迭代器接口</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="#覆盖默认迭代器">覆盖默认迭代器</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="#遍历器对象的-return、throw">遍历器对象的 return、throw</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="#for-of-1">for...of</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="#for-in">for...in</a><!----></li></ul></li><li class="sidebar-link"><a class="sidebar-link-item" href="#async-函数">async 函数</a><ul class="sidebar-links"><li class="sidebar-link"><a class="sidebar-link-item" href="#await">await</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="#错误处理">错误处理</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="#内部实现">内部实现</a><!----></li></ul></li><li class="sidebar-link"><a class="sidebar-link-item" href="#modules">Modules</a><ul class="sidebar-links"><li class="sidebar-link"><a class="sidebar-link-item" href="#export">export</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="#import">import</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="#export-default">export default</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="#export-import-复合写法">export &amp; import 复合写法</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="#跨模块常量">跨模块常量</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="#import-1">import()</a><!----></li></ul></li></ul></li><li class="sidebar-link"><a class="sidebar-link-item" href="/yl/yl/">vue</a><!----></li></ul></li><li class="sidebar-link"><p class="sidebar-link-item">larjdns</p><!----></li><!--]--></ul><!--[--><!--]--></aside><div class="sidebar-mask"></div><main class="page" data-v-7eddb2c4><div class="container" data-v-7eddb2c4><!--[--><!--]--><div style="position:relative;" class="content" data-v-7eddb2c4><div><h1 id="es6-系列" tabindex="-1">ES6 系列 <a class="header-anchor" href="#es6-系列" aria-hidden="true">#</a></h1><p><img src="/yl/1.jpg" alt=""></p><h2 id="函数的扩展" tabindex="-1">函数的扩展 <a class="header-anchor" href="#函数的扩展" aria-hidden="true">#</a></h2><ul><li><p>函数的 length 属性指的是预期传入函数的参数长度</p></li><li><p>剩余参数末尾不能接其他参数</p></li><li><p>bind 返回的函数，name 属性值会加上 bound 前缀</p></li></ul><div class="language-js"><pre><code><span class="token comment">// 所以在模拟 bind 方法的时候这个可能是模拟不出来的</span>
<span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token function">foo</span><span class="token punctuation">.</span><span class="token function">bind</span><span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span>name <span class="token comment">// &quot;bound foo&quot;</span>

<span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">bind</span><span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span>name <span class="token comment">// &quot;bound &quot;</span>
</code></pre></div><h3 id="箭头函数" tabindex="-1">箭头函数 <a class="header-anchor" href="#箭头函数" aria-hidden="true">#</a></h3><p>🔑 箭头函数的作用是使得回调函数的语法更加简洁</p><div class="language-js"><pre><code>arrayList<span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span><span class="token parameter">item</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token comment">// 替换了</span>
arrayList<span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
     
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre></div><p>❗ 普通函数内部的 this 指向函数运行时所在的对象，箭头函数的 this 就是 | 定义时上层作用域 | 指向的 this，也就是说箭头函数的 this 是固定的，不允许通过其他类似 call / apply 的方式进行修改。</p><div class="language-js"><pre><code><span class="token comment">// ES6</span>
<span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&#39;id:&#39;</span><span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">.</span>id<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// ES5</span>
<span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">var</span> _this <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">;</span>

  <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&#39;id:&#39;</span><span class="token punctuation">,</span> _this<span class="token punctuation">.</span>id<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>❗ 对象不构成作用域使得最后下面的 this 指向 window</p><div class="language-js"><pre><code><span class="token keyword">const</span> cat <span class="token operator">=</span> <span class="token punctuation">{</span>
  <span class="token literal-property property">lives</span><span class="token operator">:</span> <span class="token number">9</span><span class="token punctuation">,</span>
  <span class="token function-variable function">jumps</span><span class="token operator">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>lives<span class="token operator">--</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><h3 id="function-prototype-tostring" tabindex="-1">Function.prototype.toString <a class="header-anchor" href="#function-prototype-tostring" aria-hidden="true">#</a></h3><p>🔑 toString 方法会返回函数代码本身，而且新版本的内置方法会保留函数的注释</p><h3 id="catch-命令的参数省略" tabindex="-1">catch 命令的参数省略 <a class="header-anchor" href="#catch-命令的参数省略" aria-hidden="true">#</a></h3><div class="language-js"><pre><code><span class="token keyword">try</span> <span class="token punctuation">{</span>
<span class="token punctuation">}</span><span class="token keyword">catch</span><span class="token punctuation">(</span>err<span class="token punctuation">)</span><span class="token punctuation">{</span>
    
<span class="token punctuation">}</span>
<span class="token comment">// 以往我们在写 try...catch 的时候通常会这样子去写</span>
<span class="token comment">// 但其实很多时候我们是不需要 err 传参的</span>

<span class="token keyword">try</span> <span class="token punctuation">{</span><span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token comment">// 所以在新版中我们可以像上面一样去写</span>
</code></pre></div><h2 id="数组的扩展" tabindex="-1">数组的扩展 <a class="header-anchor" href="#数组的扩展" aria-hidden="true">#</a></h2><h2 id="object" tabindex="-1">Object <a class="header-anchor" href="#object" aria-hidden="true">#</a></h2><p>对象一些方法的集合</p><h3 id="object-hasownproperties" tabindex="-1">Object.hasOwnProperties <a class="header-anchor" href="#object-hasownproperties" aria-hidden="true">#</a></h3><p>方法返回一个由指定对象的所有自身属性的属性名（包括不可枚举属性但不包括Symbol值作为名称的属性）组成的数组.</p><h2 id="字符串的新增方法" tabindex="-1">字符串的新增方法 <a class="header-anchor" href="#字符串的新增方法" aria-hidden="true">#</a></h2><h3 id="padstart-padend" tabindex="-1">padStart &amp; padEnd <a class="header-anchor" href="#padstart-padend" aria-hidden="true">#</a></h3><ul><li><p>实例方法；用于在头部补全字符串</p></li><li><p>参数列表：</p></li></ul><p>​ len - 字符串补全生成的最大长度</p><p>​ str - 用于补全的字符串</p><div class="language-js"><pre><code><span class="token comment">// 比如在大数相加中 两个数的位数不一样的时候需要进行头部补全</span>
<span class="token keyword">function</span> <span class="token function">bigAdd</span><span class="token punctuation">(</span><span class="token parameter">a<span class="token punctuation">,</span> b</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> <span class="token constant">MAXL</span> <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>a<span class="token punctuation">.</span>length<span class="token punctuation">,</span> b<span class="token punctuation">.</span>length<span class="token punctuation">)</span>
    a <span class="token operator">=</span> a<span class="token punctuation">.</span><span class="token function">padStart</span><span class="token punctuation">(</span><span class="token constant">MAXL</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span>
    b <span class="token operator">=</span> b<span class="token punctuation">.</span><span class="token function">padStart</span><span class="token punctuation">(</span><span class="token constant">MAXL</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span>
    <span class="token comment">// .......进行下一步的累加处理</span>
<span class="token punctuation">}</span>
</code></pre></div><p>补全的规则</p><ul><li>如果原字符串的长度大于等于指定的长度，返回原字符串</li><li>如果用于补全的 str 长度和原字符串长度累加大于 len，截取掉超出长度的 部分 str 字符(填满了就行的意思)</li></ul><hr><h3 id="trimstart-trimend" tabindex="-1">trimStart &amp; trimEnd <a class="header-anchor" href="#trimstart-trimend" aria-hidden="true">#</a></h3><ul><li><p>作用和 trim 是一样的，只是说现在将 trim 分成了首尾两种，去首就用</p><p>trimStart，去尾就用 trimEnd。</p></li><li><p>@result：总是返回新的字符串</p></li><li><p>除了空格键，这两个方法对字符串头部（或尾部）的 \t、\n等不可见的空白符号也有效</p></li></ul><hr><h3 id="includes-startswith-endswith" tabindex="-1">includes &amp; startsWith &amp; endsWith <a class="header-anchor" href="#includes-startswith-endswith" aria-hidden="true">#</a></h3><p>提供了三个方法来判断一个字符串是否包含另外一个字符串</p><ul><li>includes : 返回布尔值，表示是否找到了参数字符串</li><li>startsWith：返回布尔值，表示参数字符串是否在原字符串的头部</li><li>endsWith：返回布尔值，表示参数字符串是否在原字符串的尾部</li></ul><div class="language-js"><pre><code><span class="token keyword">let</span> s <span class="token operator">=</span> <span class="token string">&#39;Hello world!&#39;</span><span class="token punctuation">;</span>

console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span><span class="token function">endsWith</span><span class="token punctuation">(</span><span class="token string">&#39;Hello &#39;</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">// true 针对是前 6 个字符</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span><span class="token function">endsWith</span><span class="token punctuation">(</span><span class="token string">&#39;hello &#39;</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">// false 大小写敏感</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span><span class="token function">startsWith</span><span class="token punctuation">(</span><span class="token string">&#39;world&#39;</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">// true 从第7个字符串开始比较</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span><span class="token function">startsWith</span><span class="token punctuation">(</span><span class="token string">&#39; world&#39;</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">// false</span>
</code></pre></div><h2 id="set-map" tabindex="-1">Set &amp; Map <a class="header-anchor" href="#set-map" aria-hidden="true">#</a></h2><p>ES6 引出的新的数据结构，本质也是为了补充 ES5 数组对象等在使用场景上有限的问题。</p><h3 id="set-结构" tabindex="-1">Set 结构 <a class="header-anchor" href="#set-结构" aria-hidden="true">#</a></h3><p>set 作为集合的一个概念，里面不存在相等的元素。其实本质上是使用 类似JS 的 === 算法来进行判断的，也就是说 -0 和 +0 在 === 是相等的，那就不会被重新添加到结构中。</p><div class="language-js"><pre><code><span class="token number">NaN</span> <span class="token operator">===</span> <span class="token number">NaN</span> <span class="token comment">// JS 认为这个是 false</span>
</code></pre></div><p>❗ 需要注意以下几点</p><ul><li><p>在 set 中 NaN 和 NaN 不会重复</p></li><li><p>在 set 中 null 和 null / undefined 和 undefined不会重复</p></li><li><p>引用类型数组，对象等引用类型会出现重复(因为它们都是不同的引用)</p></li></ul><h3 id="map-结构" tabindex="-1">Map 结构 <a class="header-anchor" href="#map-结构" aria-hidden="true">#</a></h3><h2 id="promise-对象" tabindex="-1">*Promise 对象 <a class="header-anchor" href="#promise-对象" aria-hidden="true">#</a></h2><p>🔑 Promise 是一种异步编程的解决方案，本质上是为了解决以前的回调地狱的问题。</p><h3 id="promise-缺点" tabindex="-1">Promise 缺点 <a class="header-anchor" href="#promise-缺点" aria-hidden="true">#</a></h3><ul><li>无法取消，一旦新建就会立即执行，无法中途取消</li><li>如果不设置回调函数，Promise 内部抛出的错误不会反应到外部</li></ul><div class="language-js"><pre><code><span class="token keyword">const</span> promise <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">resolve<span class="token punctuation">,</span> reject</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token keyword">throw</span> <span class="token punctuation">(</span><span class="token string">&#39;Error&#39;</span><span class="token punctuation">)</span>
    <span class="token function">resolve</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token comment">// 里面的这个错误完全被吃掉了，对外部不产生任何的影响</span>
<span class="token comment">// 本质上其实是 promise 内部进行了一个 try...catch 的处理</span>
</code></pre></div><ul><li>当处于 pending 状态的时候无法得出目前处于哪一个阶段(刚开始/即将完成???)</li></ul><h3 id="promise-特点" tabindex="-1">Promise 特点 <a class="header-anchor" href="#promise-特点" aria-hidden="true">#</a></h3><ol><li>状态单一转换途径 -- 只能由内部的 resolve 和 reject 改变，不受外界的影响</li><li>状态不可逆 / 不可变 -- 一旦状态由 pending 变到 resolve / reject 就不能再次改变</li></ol><h3 id="promise-注意事项" tabindex="-1">Promise 注意事项 <a class="header-anchor" href="#promise-注意事项" aria-hidden="true">#</a></h3><ul><li>当返回一个 promise 后状态直接依赖于返回的 promise</li></ul><div class="language-js"><pre><code><span class="token keyword">const</span> p1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">resolve<span class="token punctuation">,</span> reject</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token function">reject</span><span class="token punctuation">(</span><span class="token string">&#39;fail&#39;</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">3000</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>

<span class="token keyword">const</span> p2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">resolve<span class="token punctuation">,</span> reject</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token function">resolve</span><span class="token punctuation">(</span>p1<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">1000</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>

<span class="token comment">// p2 的状态依赖于p1 的状态</span>
p2
  <span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token parameter">result</span> <span class="token operator">=&gt;</span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span><span class="token punctuation">)</span>
  <span class="token punctuation">.</span><span class="token function">catch</span><span class="token punctuation">(</span><span class="token parameter">error</span> <span class="token operator">=&gt;</span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>error<span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token comment">// Error: fail</span>
</code></pre></div><ul><li>调用 resolve 或 reject 并不会终结 Promise 的参数函数的执行，如下 resolve 了以后后面的代码都会执行，所以保险地来说我们一般会在 resolve 后加上 return 保证当前 promise 内部的执行完成</li></ul><div class="language-js"><pre><code><span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">resolve<span class="token punctuation">,</span> reject</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  <span class="token function">resolve</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token parameter">r</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>r<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 2</span>
<span class="token comment">// 1</span>
</code></pre></div><h3 id="promise-prototype-then" tabindex="-1">Promise.prototype.then <a class="header-anchor" href="#promise-prototype-then" aria-hidden="true">#</a></h3><p>then 方法的作用是为 Promise 提供状态变换后的回调执行。返回的是一个新的 Promise 对象，如果 then 内部 return 的是一个基本值的话，新 Promise 的状态会直接 resolve；如果 return 的是一个 Promise，会执行 Promise.then(resolve, reject) 的操作，也就是状态的变化完全依赖于 return 的 promise。</p><div class="language-js"><pre><code><span class="token keyword">let</span> promise <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">resolve<span class="token punctuation">,</span> reject</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token function">resolve</span><span class="token punctuation">(</span><span class="token string">&#39;hello&#39;</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>

promise<span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token parameter">res</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>res<span class="token punctuation">)</span> <span class="token comment">// hello</span>
    <span class="token keyword">return</span> <span class="token string">&#39;world&#39;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token parameter">res</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>res<span class="token punctuation">)</span> <span class="token comment">// world</span>
    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">resolve<span class="token punctuation">,</span> reject</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
        <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token function">resolve</span><span class="token punctuation">(</span><span class="token string">&#39;Sunday&#39;</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">2000</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token parameter">res</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span><span class="token comment">// 执行的时机依赖于上一个then 返回的 promise</span>
	console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>res<span class="token punctuation">)</span> <span class="token comment">// 2000 ms 后输出 Sunday</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre></div><h3 id="promise-prototype-catch" tabindex="-1">Promise.prototype.catch <a class="header-anchor" href="#promise-prototype-catch" aria-hidden="true">#</a></h3><p>catch 方法其实是 then(null, () =&gt; {}) 的表现形式，也就是只捕获错误后执行的回调函数。里面比较重要的是一个叫 ”错误透传“ 的概念。</p><div class="language-js"><pre><code><span class="token keyword">const</span> promise <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">resolve<span class="token punctuation">,</span> reject</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token function">reject</span><span class="token punctuation">(</span><span class="token string">&#39;err&#39;</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token parameter">value</span> <span class="token operator">=&gt;</span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&#39;suc1&#39;</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">// 透传</span>
<span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token parameter">value</span> <span class="token operator">=&gt;</span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&#39;suc2&#39;</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">//透传</span>
<span class="token punctuation">.</span><span class="token function">catch</span><span class="token punctuation">(</span><span class="token parameter">reason</span> <span class="token operator">=&gt;</span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>reason<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">// 捕获</span>
<span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token parameter">value</span> <span class="token operator">=&gt;</span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&#39;suc3&#39;</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">// 会执行不??? 会的</span>
<span class="token comment">// 为啥??? 因为 catch 其实返回的也是一个 promise，执行完成状态也就会变成 fulfilled</span>
<span class="token comment">// Promise&lt;fulfilled&gt; undefined</span>
</code></pre></div><p>其实透传就是忽略掉中间经过的 then 然后被第一个 catch 捕获掉.</p><p>❗ 关于 promise 内部的错误其实还是蛮怪异的(这也是为什么会有 generator 生成器来处理异步任务的原因之一) -- promise 内部会吃掉错误</p><div class="language-js"><pre><code><span class="token comment">// 官网的一个例子</span>
<span class="token keyword">const</span> <span class="token function-variable function">someAsyncThing</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">resolve<span class="token punctuation">,</span> reject</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 下面一行会报错，因为x没有声明</span>
    <span class="token function">resolve</span><span class="token punctuation">(</span>x <span class="token operator">+</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token function">someAsyncThing</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&#39;everything is great&#39;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">123</span><span class="token punctuation">)</span> <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">2000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// Uncaught (in promise) ReferenceError: x is not defined</span>
<span class="token comment">// 123</span>
</code></pre></div><p>但是在 node 和在浏览器中执行的结果不一致，为啥呢？node 里面其实是做了这么一个限制，也就是如果 promise 内部有未捕获的错误会直接终止进程(本地的 node 版本是 V16.13.1 可能在低版本中并不会存在这样的限制)</p><h3 id="promise-prototype-finally" tabindex="-1">Promise.prototype.finally <a class="header-anchor" href="#promise-prototype-finally" aria-hidden="true">#</a></h3><p>参数: callback() 不接受任何参数</p><ul><li><p>finally 等价于 then(callback, callback)，也就是无论 promise 的状态如何改变都是会执行传入的callback 函数。</p></li><li><p>finally 返回的也是一个 promise 对象</p><div class="language-js"><pre><code><span class="token comment">// finall</span>
<span class="token class-name">Promise</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">finally</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">callback</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> <span class="token constant">P</span> <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>constructor
    <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span>
    	<span class="token punctuation">(</span><span class="token parameter">val</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token constant">P</span><span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">(</span><span class="token function">callback</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> val<span class="token punctuation">)</span><span class="token punctuation">,</span>
        <span class="token punctuation">(</span><span class="token parameter">reason</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token constant">P</span><span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">(</span><span class="token function">callback</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span> <span class="token keyword">throw</span> reason <span class="token punctuation">}</span><span class="token punctuation">)</span>
    <span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre></div></li></ul><h3 id="promise-resolve" tabindex="-1">Promise.resolve <a class="header-anchor" href="#promise-resolve" aria-hidden="true">#</a></h3><p>方法是将一个参数封装为 promise 独享返回的过程。</p><div class="language-js"><pre><code>Promise<span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">(</span><span class="token string">&#39;foo&#39;</span><span class="token punctuation">)</span>
<span class="token comment">// 等价于</span>
<span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token parameter">resolve</span> <span class="token operator">=&gt;</span> <span class="token function">resolve</span><span class="token punctuation">(</span><span class="token string">&#39;foo&#39;</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
</code></pre></div><p>❗ 需要特别注意 resolve 的参数传递类型</p><ol><li>参数是 Promise 实例</li></ol><p>​ 如果参数是 Promise 实例，那么Promise.resolve将不做任何修改、原封不动地返回这个实例。</p><ol start="2"><li>参数是 thenable 对象</li></ol><div class="language-js"><pre><code><span class="token comment">// 具备 then 方法的对象</span>
<span class="token keyword">let</span> thenable <span class="token operator">=</span> <span class="token punctuation">{</span>
  <span class="token function-variable function">then</span><span class="token operator">:</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">resolve<span class="token punctuation">,</span> reject</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">resolve</span><span class="token punctuation">(</span><span class="token number">42</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div><p>Promise.resolve()方法会将这个对象转为 Promise 对象，然后就立即执行thenable对象的then()方法。</p><ol start="3"><li>参数不是具备 then() 方法的对象，或根本不是对象</li></ol><p>​ 返回一个新的 promise 对象，状态为 resolve，传递的值就是 Promise.resolve 出去的值</p><div class="language-js"><pre><code><span class="token keyword">const</span> promise <span class="token operator">=</span> Promise<span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">(</span><span class="token string">&#39;hello&#39;</span><span class="token punctuation">)</span>
<span class="token comment">/*
	promise 的数据类型 Promise&lt;fulfilled&gt; 值是 &#39;hello&#39;
*/</span>
</code></pre></div><ol start="4"><li>参数是一个函数</li></ol><p>​ 会先执行函数，然后将函数的返回值作为新 promise 对象的值</p><div class="language-js"><pre><code><span class="token keyword">function</span> <span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token string">&#39;jzy&#39;</span>
    <span class="token comment">// 没有就是返回 undefined</span>
<span class="token punctuation">}</span>
<span class="token keyword">const</span> promise <span class="token operator">=</span> Promise<span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">(</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
promise<span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token parameter">res</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>res<span class="token punctuation">)</span> <span class="token comment">// jzy || undefined</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre></div><h2 id="reflect-对象" tabindex="-1">Reflect 对象 <a class="header-anchor" href="#reflect-对象" aria-hidden="true">#</a></h2><p>Reflect 是 ES6 引出用来操作对象的 API。</p><p>关键字：对象相同行为；函数式编程</p><h3 id="设计目标" tabindex="-1">设计目标 <a class="header-anchor" href="#设计目标" aria-hidden="true">#</a></h3><ul><li>抽取 Object 对象内一些内部方法</li><li>修改某些 Object 方法的返回结果使其变得更合理</li><li>让 Object 操作变成函数式行为</li><li>提供与 proxy 一致的函数签名</li></ul><h3 id="reflect-get" tabindex="-1">Reflect.get <a class="header-anchor" href="#reflect-get" aria-hidden="true">#</a></h3><p>Reflect.get(target, name, receiver)</p><ul><li>返回 target 对象的 name 属性</li></ul><div class="language-js"><pre><code><span class="token keyword">var</span> myObject <span class="token operator">=</span> <span class="token punctuation">{</span>
  <span class="token literal-property property">foo</span><span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">,</span>
  <span class="token literal-property property">bar</span><span class="token operator">:</span> <span class="token number">2</span><span class="token punctuation">,</span>
  <span class="token keyword">get</span> <span class="token function">baz</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>foo <span class="token operator">+</span> <span class="token keyword">this</span><span class="token punctuation">.</span>bar<span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span>

<span class="token keyword">var</span> tar <span class="token operator">=</span> <span class="token punctuation">{</span>
    <span class="token literal-property property">foo</span><span class="token operator">:</span> <span class="token number">3</span><span class="token punctuation">,</span>
    <span class="token literal-property property">bar</span><span class="token operator">:</span> <span class="token number">4</span>
<span class="token punctuation">}</span>


console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>Reflect<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>myObject<span class="token punctuation">,</span> <span class="token string">&#39;baz&#39;</span><span class="token punctuation">,</span> tar<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">// 7</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>Reflect<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>myObject<span class="token punctuation">,</span> <span class="token string">&#39;foo&#39;</span><span class="token punctuation">,</span> tar<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">// 1</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>Reflect<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">,</span> <span class="token string">&#39;foo&#39;</span><span class="token punctuation">,</span> tar<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">// TypeError: Reflect.get called on non-object</span>
</code></pre></div><p>⭐ 有两个需要注意的地方</p><ul><li>如果 target 传入的是非对象，会报错</li><li>name 部署了 get 方法且在存在 receiver 的情况下 ---&gt; get 方法的 this 会指向 receiver</li></ul><h3 id="reflect-set" tabindex="-1">Reflect.set <a class="header-anchor" href="#reflect-set" aria-hidden="true">#</a></h3><p>Reflect.set(target, name, value, receiver)</p><ul><li>设置 target 属性的 name 等于 value</li></ul><div class="language-js"><pre><code><span class="token keyword">var</span> myObject <span class="token operator">=</span> <span class="token punctuation">{</span>
  <span class="token literal-property property">foo</span><span class="token operator">:</span> <span class="token number">4</span><span class="token punctuation">,</span>
  <span class="token keyword">set</span> <span class="token function">bar</span><span class="token punctuation">(</span><span class="token parameter">value</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>foo <span class="token operator">=</span> value<span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">var</span> myReceiverObject <span class="token operator">=</span> <span class="token punctuation">{</span>
  <span class="token literal-property property">foo</span><span class="token operator">:</span> <span class="token number">0</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token comment">// 传入 receiver，set 方法的 this 指向的就是 myReceiverObject</span>
<span class="token comment">// 对 this.foo 的修改其实就是对 myReceiverObject.foo 的修改</span>
Reflect<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>myObject<span class="token punctuation">,</span> <span class="token string">&#39;bar&#39;</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> myReceiverObject<span class="token punctuation">)</span><span class="token punctuation">;</span>
myObject<span class="token punctuation">.</span>foo <span class="token comment">// 4</span>
myReceiverObject<span class="token punctuation">.</span>foo <span class="token comment">// 1</span>
</code></pre></div><div class="language-js"><pre><code><span class="token keyword">let</span> p <span class="token operator">=</span> <span class="token punctuation">{</span>
    <span class="token literal-property property">a</span><span class="token operator">:</span> <span class="token string">&#39;a&#39;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">let</span> handler <span class="token operator">=</span> <span class="token punctuation">{</span>
    <span class="token comment">// target 指的是绑定代理的目标也就是 p</span>
    <span class="token comment">// receiver 指的是 proxy 实例也就是 ooo</span>
    <span class="token function">set</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">,</span> receiver<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        Reflect<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">,</span> receiver<span class="token punctuation">)</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">let</span> ooo <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Proxy</span><span class="token punctuation">(</span>p<span class="token punctuation">,</span> handler<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>⭐ 有两个需要注意的地方(与 get 是类似的)</p><ul><li>如果 target 传入的是非对象，会报错</li><li>name 部署了 set方法且在存在 receiver 的情况下 ---&gt; set 方法的 this 会指向 receiver</li></ul><h3 id="reflect-has" tabindex="-1">Reflect.has <a class="header-anchor" href="#reflect-has" aria-hidden="true">#</a></h3><p>Reflect.has(obj, name)</p><div class="language-js"><pre><code><span class="token keyword">const</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token literal-property property">foo</span><span class="token operator">:</span> <span class="token string">&#39;&#39;</span> <span class="token punctuation">}</span>
<span class="token comment">// &#39;foo&#39; in obj === Reflect.has(obj, &#39;foo&#39;)</span>
</code></pre></div><h3 id="reflect-deleteproperty" tabindex="-1">Reflect.deleteProperty <a class="header-anchor" href="#reflect-deleteproperty" aria-hidden="true">#</a></h3><p>Reflect.deleteProperty(obj, name)</p><div class="language-js"><pre><code><span class="token keyword">const</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span>
    <span class="token literal-property property">foo</span><span class="token operator">:</span> <span class="token string">&#39;&#39;</span>
<span class="token punctuation">}</span>
<span class="token comment">// delete obj.foo === Reflect.deleteProperty(obj, &#39;foo&#39;)</span>
</code></pre></div><h3 id="reflect-constructor" tabindex="-1">Reflect.constructor <a class="header-anchor" href="#reflect-constructor" aria-hidden="true">#</a></h3><p>Reflect.constructor(function, args)</p><div class="language-js"><pre><code><span class="token keyword">function</span> <span class="token function">Person</span><span class="token punctuation">(</span><span class="token parameter">name<span class="token punctuation">,</span> age</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name
    <span class="token keyword">this</span><span class="token punctuation">.</span>age <span class="token operator">=</span> age
<span class="token punctuation">}</span>
<span class="token comment">// const p = new Person(&#39;name&#39;)</span>
<span class="token comment">// const p = Reflect.construct(Person, [&#39;name&#39;, &#39;age&#39;])</span>
</code></pre></div><p>⭐需要注意两点</p><ul><li>function 传入的必须是一个函数(因为是 new 行为)</li><li>args 传入的必须是一个数组，表示构造函数的参数</li></ul><h3 id="reflect-getprototypeof" tabindex="-1">Reflect.getPrototypeOf <a class="header-anchor" href="#reflect-getprototypeof" aria-hidden="true">#</a></h3><p>Reflect.getPrototypeOf(obj) - 读取对象的 <em><em>proto</em>_</em> 属性</p><div class="language-js"><pre><code><span class="token keyword">const</span> myObj <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">FancyThing</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// 旧写法</span>
Object<span class="token punctuation">.</span><span class="token function">getPrototypeOf</span><span class="token punctuation">(</span>myObj<span class="token punctuation">)</span> <span class="token operator">===</span> <span class="token class-name">FancyThing</span><span class="token punctuation">.</span>prototype<span class="token punctuation">;</span>

<span class="token comment">// 新写法</span>
Reflect<span class="token punctuation">.</span><span class="token function">getPrototypeOf</span><span class="token punctuation">(</span>myObj<span class="token punctuation">)</span> <span class="token operator">===</span> <span class="token class-name">FancyThing</span><span class="token punctuation">.</span>prototype<span class="token punctuation">;</span>
</code></pre></div><p>⭐传入的 obj 必须为 Object 对象 否则会报错</p><h3 id="reflect-setprototypeof" tabindex="-1">Reflect.setPrototypeOf <a class="header-anchor" href="#reflect-setprototypeof" aria-hidden="true">#</a></h3><p>Reflect.setPrototypeOf(obj, newProto)</p><ul><li>设置对象的 _<em>proto_</em> 属性</li></ul><div class="language-js"><pre><code>Reflect<span class="token punctuation">.</span><span class="token function">setPrototypeOf</span><span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token comment">// true</span>
Reflect<span class="token punctuation">.</span><span class="token function">setPrototypeOf</span><span class="token punctuation">(</span>Object<span class="token punctuation">.</span><span class="token function">freeze</span><span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token comment">// false</span>
Reflect<span class="token punctuation">.</span><span class="token function">setPrototypeOf</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token comment">// TypeError</span>
Reflect<span class="token punctuation">.</span><span class="token function">setPrototypeOf</span><span class="token punctuation">(</span><span class="token keyword">undefined</span><span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token comment">// TypeError</span>
Reflect<span class="token punctuation">.</span><span class="token function">setPrototypeOf</span><span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token comment">// TypeError</span>
</code></pre></div><p>⭐ 需要注意两点</p><ul><li>obj 传入的必须是 Object 对象</li><li>newProto 必须是 null 或者 Object 对象</li></ul><h3 id="reflect-apply" tabindex="-1">Reflect.apply <a class="header-anchor" href="#reflect-apply" aria-hidden="true">#</a></h3><p>Reflect.apply(func, thisArg, args)</p><ul><li>绑定 thisArg 后传入 args 执行 func函数</li></ul><div class="language-js"><pre><code><span class="token keyword">const</span> ages <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">11</span><span class="token punctuation">,</span> <span class="token number">33</span><span class="token punctuation">,</span> <span class="token number">12</span><span class="token punctuation">,</span> <span class="token number">54</span><span class="token punctuation">,</span> <span class="token number">18</span><span class="token punctuation">,</span> <span class="token number">96</span><span class="token punctuation">]</span><span class="token punctuation">;</span>

<span class="token keyword">const</span> youngest <span class="token operator">=</span> <span class="token function">Reflect</span><span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span>Math<span class="token punctuation">.</span>min<span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">,</span> ages<span class="token punctuation">)</span>
<span class="token comment">// const youngest = Math.min(...ages) // 不使用 apply也可以使用解构赋值的方式</span>
<span class="token keyword">const</span> type <span class="token operator">=</span> <span class="token class-name">Object</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>youngest<span class="token punctuation">)</span><span class="token punctuation">;</span>

console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>youngest<span class="token punctuation">)</span> <span class="token comment">// 11</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>type<span class="token punctuation">)</span>  <span class="token comment">// [object Number]</span>
</code></pre></div><p>⭐需要注意</p><ul><li>func 传入的必须是 Function</li></ul><h3 id="reflect-defineproperty" tabindex="-1">Reflect.defineProperty <a class="header-anchor" href="#reflect-defineproperty" aria-hidden="true">#</a></h3><p>Reflect.defineProperty(target, propertyKey, attributes)</p><ul><li>等同于 Object.defineProperty，用于定义某个属性的 configurable, enumerable, writable, value, get, set等，未来会替代 Object.defineProperty</li></ul><div class="language-js"><pre><code><span class="token keyword">const</span> p <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Proxy</span><span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>
  <span class="token function">set</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">,</span> receiver<span class="token punctuation">)</span><span class="token punctuation">{</span>
      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&#39;set&#39;</span><span class="token punctuation">)</span>
      <span class="token keyword">return</span> Reflect<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">)</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token function">defineProperty</span><span class="token punctuation">(</span><span class="token parameter">target<span class="token punctuation">,</span> prop<span class="token punctuation">,</span> descriptor</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>descriptor<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> Reflect<span class="token punctuation">.</span><span class="token function">defineProperty</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> prop<span class="token punctuation">,</span> descriptor<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

p<span class="token punctuation">.</span>foo <span class="token operator">=</span> <span class="token string">&#39;bar&#39;</span><span class="token punctuation">;</span> <span class="token comment">// {value: &quot;bar&quot;, writable: true, enumerable: true, configurable: true}</span>
</code></pre></div><p>⭐ set 和 defineProperty 的触发场景</p><ul><li>如果设置了 set 方法且 Reflect.set 不传入 receiver 则不会触发 defineProperty</li><li>Reflect.set一旦传入receiver，就会将属性赋值到receiver上面，导致触发defineProperty拦截</li></ul><h3 id="reflect-getownpropertydescriptor" tabindex="-1">Reflect.getOwnPropertyDescriptor <a class="header-anchor" href="#reflect-getownpropertydescriptor" aria-hidden="true">#</a></h3><p>Reflect.getOwnPropertyDescriptor(target, propertyKey)</p><ul><li>获取对象的 descriptor</li></ul><div class="language-js"><pre><code><span class="token keyword">var</span> myObject <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
Object<span class="token punctuation">.</span><span class="token function">defineProperty</span><span class="token punctuation">(</span>myObject<span class="token punctuation">,</span> <span class="token string">&#39;hidden&#39;</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>
  <span class="token literal-property property">value</span><span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>
  <span class="token literal-property property">enumerable</span><span class="token operator">:</span> <span class="token boolean">false</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>Reflect<span class="token punctuation">.</span><span class="token function">getOwnPropertyDescriptor</span><span class="token punctuation">(</span>myObject<span class="token punctuation">,</span> <span class="token string">&#39;hidden&#39;</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token comment">//  {&quot;value&quot;:true,&quot;writable&quot;:false,&quot;enumerable&quot;:false,&quot;configurable&quot;:false}</span>
</code></pre></div><p>🔑通过上面的输出我们可以知道默认的 descriptor</p><div class="language-js"><pre><code><span class="token punctuation">{</span><span class="token string-property property">&quot;writable&quot;</span><span class="token operator">:</span><span class="token boolean">false</span><span class="token punctuation">,</span><span class="token string-property property">&quot;enumerable&quot;</span><span class="token operator">:</span><span class="token boolean">false</span><span class="token punctuation">,</span><span class="token string-property property">&quot;configurable&quot;</span><span class="token operator">:</span><span class="token boolean">false</span><span class="token punctuation">}</span> 
</code></pre></div><h3 id="reflect-isextensible" tabindex="-1">Reflect.isExtensible <a class="header-anchor" href="#reflect-isextensible" aria-hidden="true">#</a></h3><p>Reflect.isExtensible (target)</p><ul><li>返回 boolean 表示 target 是否可扩展</li></ul><h3 id="reflect-preventextension" tabindex="-1">Reflect.preventExtension <a class="header-anchor" href="#reflect-preventextension" aria-hidden="true">#</a></h3><p>Reflect.preventExtension(target)</p><ul><li>使得 target 不可扩展(不可新增属性 / 可以 get 和 delete)</li></ul><div class="language-js"><pre><code><span class="token keyword">var</span> myObject <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
Reflect<span class="token punctuation">.</span><span class="token function">preventExtensions</span><span class="token punctuation">(</span>myObject<span class="token punctuation">)</span> <span class="token comment">// true</span>

myObject<span class="token punctuation">.</span>hello <span class="token operator">=</span> <span class="token string">&#39;hahah&#39;</span> <span class="token comment">// 不报错但是不生效</span>
</code></pre></div><h3 id="reflect-ownkeys" tabindex="-1">Reflect.ownKeys <a class="header-anchor" href="#reflect-ownkeys" aria-hidden="true">#</a></h3><p>Reflect.ownKeys (target)</p><ul><li>返回对象所有的属性</li></ul><div class="language-js"><pre><code><span class="token keyword">var</span> myObject <span class="token operator">=</span> <span class="token punctuation">{</span>
  <span class="token literal-property property">foo</span><span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">,</span>
  <span class="token literal-property property">bar</span><span class="token operator">:</span> <span class="token number">2</span><span class="token punctuation">,</span>
  <span class="token punctuation">[</span>Symbol<span class="token punctuation">.</span><span class="token function">for</span><span class="token punctuation">(</span><span class="token string">&#39;baz&#39;</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token operator">:</span> <span class="token number">3</span><span class="token punctuation">,</span>
  <span class="token punctuation">[</span>Symbol<span class="token punctuation">.</span><span class="token function">for</span><span class="token punctuation">(</span><span class="token string">&#39;bing&#39;</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token operator">:</span> <span class="token number">4</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token comment">// 旧写法</span>
Object<span class="token punctuation">.</span><span class="token function">getOwnPropertyNames</span><span class="token punctuation">(</span>myObject<span class="token punctuation">)</span>
<span class="token comment">// [&#39;foo&#39;, &#39;bar&#39;]</span>

Object<span class="token punctuation">.</span><span class="token function">getOwnPropertySymbols</span><span class="token punctuation">(</span>myObject<span class="token punctuation">)</span>
<span class="token comment">//[Symbol(baz), Symbol(bing)]</span>

<span class="token comment">// 新写法 -- 等同于上面两个之和</span>
Reflect<span class="token punctuation">.</span><span class="token function">ownKeys</span><span class="token punctuation">(</span>myObject<span class="token punctuation">)</span>
<span class="token comment">// [&#39;foo&#39;, &#39;bar&#39;, Symbol(baz), Symbol(bing)]</span>
</code></pre></div><h2 id="proxy" tabindex="-1">Proxy <a class="header-anchor" href="#proxy" aria-hidden="true">#</a></h2><ul><li>[x] 重新学习的目标是搞清楚 proxy 实例 和 target 的区别</li></ul><ul><li>里面的一些方法和 Reflect 是一样的，参数也是一样的，可以这么去理解，proxy 是一个代理器，当我们触发 proxy 的一些拦截的话会使用 Reflect 来更新对象。</li></ul><p>⭐ 监听以下的一些方法设置</p><ul><li>get</li><li>set</li><li>has</li><li>deleteProerty</li><li>constructor</li><li>getPrototypeOf</li><li>setPrototypeOf</li><li>apply</li><li>defineProperty</li><li>getOwnProtertyDescriptor</li><li>isExtensible</li><li>preventExtension</li><li>ownKeys</li></ul><h2 id="生成器-迭代器" tabindex="-1">生成器 &amp; 迭代器 <a class="header-anchor" href="#生成器-迭代器" aria-hidden="true">#</a></h2><ul><li>调用 Generator 函数，返回一个遍历器对象，代表 Generator 函数内部指针。以后每次调用遍历器的 next 方法，就会返回一个有着 value 和 done 两个属性的对象。</li><li>value - yield 表达式后面的值</li><li>done - 代表遍历是否结束</li></ul><p>⭐ 本质上，generator 是基于协程来实现的，所有在一个函数内部才会有状态这个概念。协程是不受操作系统控制的，单纯由用户控制(比如生成器的 next 方法)，才会发生状态的转换。</p><h3 id="for-of" tabindex="-1">for...of <a class="header-anchor" href="#for-of" aria-hidden="true">#</a></h3><p>for...of 循环可以自动遍历 Generator 函数运行时生成的 Interator 对象，且不需要再调用 next 方法。</p><p>我们也都知道对象其实是不可以使用 for...of 去遍历的，因此我们可以使用生成器来对对象进行改造</p><div class="language-js"><pre><code><span class="token comment">// 第一种方法</span>
<span class="token keyword">function</span><span class="token operator">*</span> <span class="token function">objectEntries</span><span class="token punctuation">(</span><span class="token parameter">obj</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// Reflect.ownkeys 拿到对象所有的键值包括 symbol</span>
  <span class="token keyword">let</span> propKeys <span class="token operator">=</span> Reflect<span class="token punctuation">.</span><span class="token function">ownKeys</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token punctuation">;</span>
	
    <span class="token comment">// 遍历对象的属性然后通过 yield 去操作</span>
  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> propKey <span class="token keyword">of</span> propKeys<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">yield</span> <span class="token punctuation">[</span>propKey<span class="token punctuation">,</span> obj<span class="token punctuation">[</span>propKey<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">let</span> jane <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token literal-property property">first</span><span class="token operator">:</span> <span class="token string">&#39;Jane&#39;</span><span class="token punctuation">,</span> <span class="token literal-property property">last</span><span class="token operator">:</span> <span class="token string">&#39;Doe&#39;</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> <span class="token punctuation">[</span>key<span class="token punctuation">,</span> value<span class="token punctuation">]</span> <span class="token keyword">of</span> <span class="token function">objectEntries</span><span class="token punctuation">(</span>jane<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>key<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">: </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>value<span class="token interpolation-punctuation punctuation">}</span></span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><div class="language-js"><pre><code><span class="token comment">// 第二种方法：对象内部新增 [Symbol.interator]: function* (){}</span>
<span class="token keyword">function</span><span class="token operator">*</span> <span class="token function">objectEntries</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">let</span> propKeys <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">keys</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> propKey <span class="token keyword">of</span> propKeys<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">yield</span> <span class="token punctuation">[</span>propKey<span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">[</span>propKey<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">let</span> jane <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token literal-property property">first</span><span class="token operator">:</span> <span class="token string">&#39;Jane&#39;</span><span class="token punctuation">,</span> <span class="token literal-property property">last</span><span class="token operator">:</span> <span class="token string">&#39;Doe&#39;</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>

jane<span class="token punctuation">[</span>Symbol<span class="token punctuation">.</span>iterator<span class="token punctuation">]</span> <span class="token operator">=</span> objectEntries<span class="token punctuation">;</span>

<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> <span class="token punctuation">[</span>key<span class="token punctuation">,</span> value<span class="token punctuation">]</span> <span class="token keyword">of</span> jane<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>key<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">: </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>value<span class="token interpolation-punctuation punctuation">}</span></span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>⭐ 需要清楚的一点是，无论是 for...of / 扩展运算符 / Array.from 都是可以将 Generator 返回的 interator 作为参数，但是遇到 done 为 true 的话就会马上停止遍历。</p><h3 id="generator-prototype-next" tabindex="-1">Generator.prototype.next() <a class="header-anchor" href="#generator-prototype-next" aria-hidden="true">#</a></h3><div class="language-js"><pre><code><span class="token comment">// 采用生成器实现延时执行函数的效果</span>
<span class="token keyword">function</span><span class="token operator">*</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&#39;执行了！&#39;</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token keyword">var</span> generator <span class="token operator">=</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  generator<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">2000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><div class="language-javascript"><pre><code><span class="token keyword">function</span><span class="token operator">*</span> <span class="token function">dataConsumer</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&#39;Started&#39;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">1 </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span><span class="token keyword">yield</span><span class="token interpolation-punctuation punctuation">}</span></span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">2 </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span><span class="token keyword">yield</span><span class="token interpolation-punctuation punctuation">}</span></span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token keyword">let</span> genObj <span class="token operator">=</span> <span class="token function">dataConsumer</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
genObj<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// started</span>
genObj<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token string">&#39;a&#39;</span><span class="token punctuation">)</span> <span class="token comment">// 1 a</span>
genObj<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token string">&#39;b&#39;</span><span class="token punctuation">)</span> <span class="token comment">// 2 b</span>
</code></pre></div><ul><li>[x] 2022 / 4 / 11 阅读到 next 传递函数</li></ul><h3 id="generator-prototype-throw" tabindex="-1">Generator.prototype.throw() <a class="header-anchor" href="#generator-prototype-throw" aria-hidden="true">#</a></h3><ul><li>执行一次 throw 附带执行一次 next</li><li>只有执行过一次 next，throw 传递的错误才能被内部捕获</li></ul><div class="language-js"><pre><code><span class="token keyword">var</span> <span class="token function-variable function">g</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token operator">*</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">try</span> <span class="token punctuation">{</span>
    <span class="token keyword">yield</span> <span class="token number">1</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span>e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&#39;函数体内：&#39;</span> <span class="token operator">+</span> e<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">var</span> i <span class="token operator">=</span> <span class="token function">g</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
i<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
i<span class="token punctuation">.</span><span class="token function">throw</span><span class="token punctuation">(</span><span class="token string">&#39;出错了~~~~&#39;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 进入函数体内错误捕获</span>
<span class="token keyword">try</span> <span class="token punctuation">{</span>
    i<span class="token punctuation">.</span><span class="token function">throw</span><span class="token punctuation">(</span><span class="token string">&#39;出错了~~~~~&#39;</span><span class="token punctuation">)</span> <span class="token comment">// 进入函数体外错误捕获</span>
<span class="token punctuation">}</span> <span class="token keyword">catch</span><span class="token punctuation">(</span>err<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&#39;函数体外：&#39;</span><span class="token punctuation">,</span> err<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre></div><p>⭐区别于全局上的 throw 函数，throw 只能被函数体外的 catch 语句捕获。同时与其他错误类似，如果没有进行正确的错误处理流程，程序将会报错(也就是 throw 了但是你没有使用 try ... catch 进行错误处理)</p><h3 id="generator-prototype-return" tabindex="-1">Generator.prototype.return() <a class="header-anchor" href="#generator-prototype-return" aria-hidden="true">#</a></h3><p>Generator 函数返回的遍历器对象，还有一个 return 方法，可以返回给定的值，并且终结遍历 Generator 函数。</p><div class="language-js"><pre><code><span class="token keyword">function</span><span class="token operator">*</span> <span class="token function">gen</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">yield</span> <span class="token number">1</span><span class="token punctuation">;</span>
  <span class="token keyword">yield</span> <span class="token number">2</span><span class="token punctuation">;</span>
  <span class="token keyword">yield</span> <span class="token number">3</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">var</span> g <span class="token operator">=</span> <span class="token function">gen</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

g<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token comment">// { value: 1, done: false }</span>
g<span class="token punctuation">.</span><span class="token function">return</span><span class="token punctuation">(</span><span class="token string">&#39;foo&#39;</span><span class="token punctuation">)</span> <span class="token comment">// { value: &quot;foo&quot;, done: true }</span>
g<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token comment">// { value: undefined, done: true }</span>
</code></pre></div><h3 id="yield" tabindex="-1">yield* <a class="header-anchor" href="#yield" aria-hidden="true">#</a></h3><p>常用在一个 Generator 函数内部调用另外一个 Generator 的情况。yield* 表示后面接着的是一个遍历器对象。</p><p>🌟可以这么去理解：yield* 表达式其实就是将 Generator 转化为 多个 yield 子表达式的过程，然后在父 Generator 再遍历的过程。</p><div class="language-js"><pre><code><span class="token comment">// 如果被代理的 Generator 函数有return语句，那么就可以向代理它的 Generator 函数返回数据</span>
<span class="token keyword">function</span><span class="token operator">*</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">yield</span> <span class="token number">2</span><span class="token punctuation">;</span>
  <span class="token keyword">yield</span> <span class="token number">3</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> <span class="token string">&quot;foo&quot;</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">function</span><span class="token operator">*</span> <span class="token function">bar</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">yield</span> <span class="token number">1</span><span class="token punctuation">;</span>
  <span class="token keyword">var</span> v <span class="token operator">=</span> <span class="token keyword">yield</span><span class="token operator">*</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 接受 foo 返回的数据</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&quot;v: &quot;</span> <span class="token operator">+</span> v<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">yield</span> <span class="token number">4</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">var</span> it <span class="token operator">=</span> <span class="token function">bar</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

it<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token comment">// {value: 1, done: false}</span>
it<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token comment">// {value: 2, done: false}</span>
it<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token comment">// {value: 3, done: false}</span>
it<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// &quot;v: foo&quot;</span>
<span class="token comment">// {value: 4, done: false}</span>
it<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token comment">// {value: undefined, done: true}</span>
</code></pre></div><ul><li>使用 yield 实现数组的 flat 扁平化</li></ul><div class="language-js"><pre><code><span class="token keyword">function</span><span class="token operator">*</span> <span class="token function">iterTree</span><span class="token punctuation">(</span><span class="token parameter">tree</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>Array<span class="token punctuation">.</span><span class="token function">isArray</span><span class="token punctuation">(</span>tree<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">let</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> tree<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">yield</span><span class="token operator">*</span> <span class="token function">iterTree</span><span class="token punctuation">(</span>tree<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
    <span class="token keyword">yield</span> tree<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">const</span> tree <span class="token operator">=</span> <span class="token punctuation">[</span> <span class="token string">&#39;a&#39;</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token string">&#39;b&#39;</span><span class="token punctuation">,</span> <span class="token string">&#39;c&#39;</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token string">&#39;d&#39;</span><span class="token punctuation">,</span> <span class="token string">&#39;e&#39;</span><span class="token punctuation">]</span> <span class="token punctuation">]</span><span class="token punctuation">;</span>

<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">let</span> x <span class="token keyword">of</span> <span class="token function">iterTree</span><span class="token punctuation">(</span>tree<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><h3 id="作为对象属性的-generator-函数" tabindex="-1">作为对象属性的 Generator 函数 <a class="header-anchor" href="#作为对象属性的-generator-函数" aria-hidden="true">#</a></h3><div class="language-js"><pre><code><span class="token keyword">let</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span>
    <span class="token comment">// 前面使用 * 标识是 Generator 函数</span>
    <span class="token operator">*</span><span class="token function">myGeneratorMethod</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><h3 id="generator-函数的-this" tabindex="-1">Generator 函数的 this <a class="header-anchor" href="#generator-函数的-this" aria-hidden="true">#</a></h3><ul><li><p>Generator 不能作为构造函数使用</p></li><li><p>Generator 原型上的属性和方法可以被继承</p></li></ul><div class="language-js"><pre><code><span class="token keyword">function</span> <span class="token operator">*</span><span class="token function">gen</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">yield</span> <span class="token keyword">this</span><span class="token punctuation">.</span>a <span class="token operator">=</span> <span class="token number">1</span>
    <span class="token keyword">yield</span> <span class="token keyword">this</span><span class="token punctuation">.</span>b <span class="token operator">=</span> <span class="token number">2</span>
<span class="token punctuation">}</span>

<span class="token comment">// 通过封装函数的方式使得 Generator 状态机可以作为构造函数</span>
<span class="token keyword">function</span> <span class="token function">Fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token function">gen</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>gen<span class="token punctuation">.</span>prototype<span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token keyword">const</span> obj <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
obj<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
obj<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>obj<span class="token punctuation">.</span>a<span class="token punctuation">)</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>obj<span class="token punctuation">.</span>b<span class="token punctuation">)</span>
</code></pre></div><h3 id="实际应用" tabindex="-1">实际应用 <a class="header-anchor" href="#实际应用" aria-hidden="true">#</a></h3><ul><li>异步操作同步化表达</li></ul><div class="language-js"><pre><code><span class="token keyword">function</span> <span class="token operator">*</span><span class="token function">gen</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">loadingData</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// 加载动画</span>
    <span class="token keyword">yield</span> <span class="token function">renderData</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// 渲染数据</span>
    <span class="token function">hideLoading</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// 隐藏加载动画</span>
<span class="token punctuation">}</span>

<span class="token keyword">const</span> g <span class="token operator">=</span> <span class="token function">gen</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// 一开始不会执行</span>
g<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// 执行到 renderData</span>
<span class="token comment">// renderData 里面再调用 g.next() 从而隐藏加载动画</span>
</code></pre></div><ul><li>部署 Interator 接口</li></ul><div class="language-js"><pre><code><span class="token keyword">const</span> <span class="token function-variable function">setUpInterator</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">obj</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 方法一就是通过往对象上添加 Symbol.inerator 属性来实现可迭代</span>
    obj<span class="token punctuation">[</span>Symbol<span class="token punctuation">.</span>iterator<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token operator">*</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">const</span> key <span class="token keyword">in</span> obj<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">if</span><span class="token punctuation">(</span>obj<span class="token punctuation">.</span><span class="token function">hasOwnProperty</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token keyword">yield</span> obj<span class="token punctuation">[</span>key<span class="token punctuation">]</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>⭐ 总的来说，generator 作为生成器函数，不像普通函数调用后就执行。返回的是一个迭代器对象，我们可以通过 for ... of 来进行迭代。内部通过 yield 关键字来实现状态机的切换，每 next 一次执行到 yield 的时候就交出对应的执行权限，对应的上下文会被缓存起来，等到下次取到状态执行权后再入栈</p><h3 id="generator-异步" tabindex="-1">Generator 异步 <a class="header-anchor" href="#generator-异步" aria-hidden="true">#</a></h3><p>❗ ES6 引入 Generator 之前也有几种方法解决JS同步阻塞的问题，常见的有回调函数 / Promise。回调函数可能出现的问题是多个回调之间存在强耦合关系导致一个操作修改会影响到其他操作，不断嵌套的过程就导致了”回调地狱“的问题。由此引出了 Promise，通过 .then .... 直观上同步的方式解决了嵌套问题，但是稍微有点不好的就是需要封装多一层 Promise 对象导致语义不清晰。</p><p>⭐ Generator 的引出解决了上面问题，本质上基于协程实现，可以控制执行时机且内部代码看上去和同步的方式一模一样，语义非常清晰，同时外部的错误可以在内部进行捕获。</p><ul><li>thunk 包装</li></ul><div class="language-js"><pre><code><span class="token comment">// 本质上是通过将 next 作为 fn 的回调函数传入</span>
<span class="token comment">// 等到 fn 执行回调的时候再恢复 Generator 的执行权</span>
<span class="token keyword">function</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token parameter">fn</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">var</span> gen <span class="token operator">=</span> <span class="token function">fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token keyword">function</span> <span class="token function">next</span><span class="token punctuation">(</span><span class="token parameter">err<span class="token punctuation">,</span> data</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">var</span> result <span class="token operator">=</span> gen<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>result<span class="token punctuation">.</span>done<span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>
    result<span class="token punctuation">.</span><span class="token function">value</span><span class="token punctuation">(</span><span class="token function">next</span><span class="token punctuation">.</span><span class="token function">bind</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">,</span> <span class="token string">&#39;filename&#39;</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 这里通过这么一种方式来模拟</span>
  <span class="token punctuation">}</span>

  <span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// thunk 包装函数</span>
<span class="token keyword">function</span> <span class="token function">thunk</span><span class="token punctuation">(</span><span class="token parameter">fn</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">const</span> args <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">slice</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>arguments<span class="token punctuation">)</span>
        <span class="token keyword">return</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">callback</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            args<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>callback<span class="token punctuation">)</span>
            <span class="token keyword">return</span> <span class="token function">fn</span><span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> args<span class="token punctuation">)</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token comment">// 模拟读取文件的异步回调</span>
<span class="token keyword">function</span> <span class="token function">log</span><span class="token punctuation">(</span><span class="token parameter">filename<span class="token punctuation">,</span> callback</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    callbacl <span class="token operator">=</span> callback <span class="token operator">?</span> <span class="token function-variable function">callback</span> <span class="token operator">:</span>  <span class="token keyword">function</span><span class="token punctuation">(</span>err<span class="token operator">=</span><span class="token keyword">null</span><span class="token punctuation">,</span> data<span class="token operator">=</span><span class="token string">&#39;file&#39;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> <span class="token string">&#39;data&#39;</span> <span class="token punctuation">}</span>
    <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token function">callback</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">5000</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token keyword">const</span> readFileThunk <span class="token operator">=</span> <span class="token function">thunk</span><span class="token punctuation">(</span>log<span class="token punctuation">)</span>

<span class="token keyword">var</span> <span class="token function-variable function">g</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token operator">*</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">var</span> f1 <span class="token operator">=</span> <span class="token keyword">yield</span> <span class="token function">readFileThunk</span><span class="token punctuation">(</span><span class="token string">&#39;file1&#39;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>f1<span class="token punctuation">)</span>
  <span class="token keyword">var</span> f2 <span class="token operator">=</span> <span class="token keyword">yield</span> <span class="token function">readFileThunk</span><span class="token punctuation">(</span><span class="token string">&#39;file2&#39;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>f2<span class="token punctuation">)</span>
  <span class="token keyword">var</span> f3 <span class="token operator">=</span> <span class="token keyword">yield</span> <span class="token function">readFileThunk</span><span class="token punctuation">(</span><span class="token string">&#39;file3&#39;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>f3<span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token function">run</span><span class="token punctuation">(</span>g<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>🐯 其实 CO 的 promise 封装和 run 方法是类似的，只是换成了 Promise.then 的方式进行回调的传入</p><h2 id="class-类" tabindex="-1">Class 类 <a class="header-anchor" href="#class-类" aria-hidden="true">#</a></h2><p>其实 Class 本质上还是使用函数去实现的，Class 只是方便我们使用的一种语法糖，并不是像Java 或者 C 里面存在真正类的定义。所以还是存在原型 &amp; 原型链的概念，规则其实也和 ES5 中是一样的。</p><div class="language-js"><pre><code><span class="token keyword">function</span> <span class="token function">Point</span><span class="token punctuation">(</span><span class="token parameter">x<span class="token punctuation">,</span> y</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 构造函数</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>x <span class="token operator">=</span> x
    <span class="token keyword">this</span><span class="token punctuation">.</span>y <span class="token operator">=</span> y
<span class="token punctuation">}</span>
<span class="token class-name">Point</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">toString</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token string">&#39;&#39;</span>
<span class="token punctuation">}</span>

<span class="token comment">// 上面的声明等价于</span>
Class Point <span class="token punctuation">{</span>
    <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token parameter">x<span class="token punctuation">,</span> y</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
		<span class="token keyword">this</span><span class="token punctuation">.</span>x <span class="token operator">=</span> x
        <span class="token keyword">this</span><span class="token punctuation">.</span>y <span class="token operator">=</span> y
    <span class="token punctuation">}</span>
    <span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>🔑 类的所有方法都在原型对象上</p><p>⚠️ 默认有一个 constructor 函数返回 this 对象，如果更改为返回其他对象，可能导致的问题是不能进行实例继承和原型继承。</p><div class="language-js"><pre><code><span class="token keyword">class</span> <span class="token class-name">Foo</span> <span class="token punctuation">{</span>
  <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> <span class="token string">&#39;hello&#39;</span>
    <span class="token keyword">return</span> Object<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token comment">// 覆盖了原来默认返回 this 的行为</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">const</span> foo <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>foo<span class="token punctuation">.</span>name<span class="token punctuation">)</span> <span class="token comment">// undefined</span>
</code></pre></div><div class="language-js"><pre><code>Object<span class="token punctuation">.</span><span class="token function">getPrototypeOf</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span> <span class="token comment">// 生产环境建议使用这种方式获取原型对象</span>
</code></pre></div><h3 id="getter-setter" tabindex="-1">getter &amp; setter <a class="header-anchor" href="#getter-setter" aria-hidden="true">#</a></h3><ul><li>Object.getOwnPropertyDescriptor</li></ul><div class="language-js"><pre><code><span class="token comment">// Object.getOwnpropertyDescriptor 用于获取某个属性的描述符</span>
<span class="token comment">// 也就是 { configurable, writable, enumerable, value }</span>
<span class="token comment">// 同时也说明了一个问题 对应的 getter 和 setter 是定义在原型上的</span>
<span class="token comment">// 且这个属性是不可枚举的因为 Object.keys 遍历不出来</span>
<span class="token keyword">var</span> descriptor <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">getOwnPropertyDescriptor</span><span class="token punctuation">(</span>
  <span class="token class-name">CustomHTMLElement</span><span class="token punctuation">.</span>prototype<span class="token punctuation">,</span> <span class="token string">&quot;html&quot;</span>
<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 返回的是一个对象 { configurable, writable, enumera }</span>
</code></pre></div><div class="language-js"><pre><code><span class="token keyword">class</span> <span class="token class-name">CustomHTMLElement</span> <span class="token punctuation">{</span>
  <span class="token keyword">get</span> <span class="token function">html</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>element<span class="token punctuation">.</span>innerHTML<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token keyword">set</span> <span class="token function">html</span><span class="token punctuation">(</span><span class="token parameter">value</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>element<span class="token punctuation">.</span>innerHTML <span class="token operator">=</span> value<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">const</span> cus <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">CustomHTMLElement</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>Object<span class="token punctuation">.</span><span class="token function">hasOwnProperty</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>cus<span class="token punctuation">.</span>__proto__<span class="token punctuation">,</span> <span class="token string">&#39;html&#39;</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">// true</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>Object<span class="token punctuation">.</span><span class="token function">hasOwnProperty</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>cus<span class="token punctuation">.</span><span class="token punctuation">,</span> <span class="token string">&#39;html&#39;</span><span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token comment">// false </span>
</code></pre></div><h3 id="class-表达式" tabindex="-1">class 表达式 <a class="header-anchor" href="#class-表达式" aria-hidden="true">#</a></h3><div class="language-js"><pre><code><span class="token keyword">const</span> MyClass <span class="token operator">=</span> <span class="token keyword">class</span> <span class="token class-name">Me</span> <span class="token punctuation">{</span>
  <span class="token function">getClassName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> Me<span class="token punctuation">.</span>name<span class="token punctuation">;</span> <span class="token comment">// Me 只能在内部使用</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token comment">// 立即执行类 =&gt; 创建对应的实例</span>
<span class="token keyword">let</span> person <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">class</span> <span class="token punctuation">{</span>
  <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token parameter">name</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token function">sayName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">(</span><span class="token string">&#39;张三&#39;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

person<span class="token punctuation">.</span><span class="token function">sayName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// &quot;张三&quot;</span>
</code></pre></div><h3 id="静态方法-静态属性" tabindex="-1">静态方法 &amp; 静态属性 <a class="header-anchor" href="#静态方法-静态属性" aria-hidden="true">#</a></h3><p>⚠️ 静态属性其实一开始的规范中是如下声明的</p><div class="language-js"><pre><code><span class="token keyword">class</span> <span class="token class-name">Person</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
Person<span class="token punctuation">.</span>name <span class="token operator">=</span> <span class="token string">&#39;name&#39;</span>
</code></pre></div><p>但是考虑到这样子不太直接所以就引入了另一种规范</p><div class="language-js"><pre><code><span class="token keyword">class</span> <span class="token class-name">Person</span> <span class="token punctuation">{</span>
    <span class="token keyword">static</span> name <span class="token operator">=</span> <span class="token string">&#39;name&#39;</span>
<span class="token punctuation">}</span>
</code></pre></div><h3 id="实例属性的新写法" tabindex="-1">实例属性的新写法 <a class="header-anchor" href="#实例属性的新写法" aria-hidden="true">#</a></h3><div class="language-js"><pre><code><span class="token keyword">class</span> <span class="token class-name">Customer</span> <span class="token punctuation">{</span>
    count <span class="token operator">=</span> <span class="token number">0</span> <span class="token comment">// 直接声明到顶部</span>
    <span class="token comment">// 但是用的时候其实还是需要 this.count</span>
    <span class="token comment">// 只是说现在一眼就能看到有哪些实例属性</span>
<span class="token punctuation">}</span>
</code></pre></div><h3 id="new-target" tabindex="-1">new.target <a class="header-anchor" href="#new-target" aria-hidden="true">#</a></h3><ul><li>在函数中 new Target 指向的是构造函数</li></ul><div class="language-js"><pre><code><span class="token keyword">function</span> <span class="token function">Person</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">new</span><span class="token punctuation">.</span>target<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
<span class="token keyword">const</span> person <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// [Person Function]</span>
</code></pre></div><ul><li>在对象中返回的是当前 Class</li></ul><div class="language-js"><pre><code><span class="token keyword">class</span> <span class="token class-name">Person</span> <span class="token punctuation">{</span>
    <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">new</span><span class="token punctuation">.</span>target<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token keyword">const</span> person <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// 指向 Class Person</span>
</code></pre></div><ul><li>在继承关系中，指向的是子类。我们可以使用这一特性来实现一个抽象类，也就是只能被继承不能被实例</li></ul><div class="language-js"><pre><code><span class="token keyword">class</span> <span class="token class-name">Person</span> <span class="token punctuation">{</span>
    <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token keyword">new</span><span class="token punctuation">.</span>target <span class="token operator">===</span> Person<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">throw</span><span class="token punctuation">(</span><span class="token string">&#39;不能被实例化&#39;</span><span class="token punctuation">)</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token keyword">class</span> <span class="token class-name">Student</span> <span class="token keyword">extends</span> <span class="token class-name">Person</span> <span class="token punctuation">{</span>
    <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">super</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><h2 id="class-继承" tabindex="-1">Class 继承 <a class="header-anchor" href="#class-继承" aria-hidden="true">#</a></h2><ul><li>ES6 继承方式和 ES5 继承方式的差别</li></ul><p>ES6 的继承机制，是先将父类的属性和方法，加到一个空的对象上面，然后再将该对象作为子类的实例，即“继承在前，实例在后”，ES5 恰恰相反“实例在先，继承在后”。因此引出了一系列的注意事项，子类的构造函数必须包含 super 调用，this 的使用必须在 super 后等等。</p><h3 id="super" tabindex="-1">super <a class="header-anchor" href="#super" aria-hidden="true">#</a></h3><div class="language-js"><pre><code><span class="token keyword">class</span> <span class="token class-name">A</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token keyword">class</span> <span class="token class-name">B</span> <span class="token punctuation">{</span>
	<span class="token function">constructor</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">super</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// 执行父类的构造函数</span>
        <span class="token comment">// 等价于 A.prototype.constructor.call(this)</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><blockquote><p>super 可以用作函数和对象。用作函数时只能在子类的构造函数中使用，且只能使用一次，内部默认的 this 指向指向的是子类的构造函数，其实也就是子类实例。作为对象使用的时候，如果在普通函数中使用， this 指向的是父类原型对象，如果在静态函数中使用， this 指向的是父类。</p></blockquote><ul><li>ES6 规定，在子类<em>普通方法</em>中通过 this 调用父类的方法时，方法内部的 this 指向当前的子类实例。</li></ul><div class="language-js"><pre><code><span class="token keyword">class</span> <span class="token class-name">A</span> <span class="token punctuation">{</span>
  <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>x <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token function">print</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">class</span> <span class="token class-name">B</span> <span class="token keyword">extends</span> <span class="token class-name">A</span> <span class="token punctuation">{</span>
  <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">super</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>x <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token function">m</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 遵循上面的规定 实际执行的是 super.print.call(this)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">let</span> b <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">B</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
b<span class="token punctuation">.</span><span class="token function">m</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// 2</span>
</code></pre></div><ul><li>ES6 规定，在子类的静态方法中通过 super 调用父类的方法时，方法内部的 this 指向当前的子类，而不是子类的实例。</li></ul><div class="language-js"><pre><code><span class="token keyword">class</span> <span class="token class-name">A</span> <span class="token punctuation">{</span>
  <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>x <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">static</span> <span class="token function">print</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">class</span> <span class="token class-name">B</span> <span class="token keyword">extends</span> <span class="token class-name">A</span> <span class="token punctuation">{</span>
  <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">super</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>x <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span> <span class="token comment">// 实例属性</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">static</span> <span class="token function">m</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token constant">B</span><span class="token punctuation">.</span>x <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span> <span class="token comment">// 静态属性</span>
<span class="token constant">B</span><span class="token punctuation">.</span><span class="token function">m</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// 3</span>
</code></pre></div><p>⚠️ 下面这段代码一直不能够理解？？？</p><div class="language-js"><pre><code><span class="token keyword">class</span> <span class="token class-name">A</span> <span class="token punctuation">{</span>
  constru	<span class="token function">ctor</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>x <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">class</span> <span class="token class-name">B</span> <span class="token keyword">extends</span> <span class="token class-name">A</span> <span class="token punctuation">{</span>
  <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">super</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>x <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>
    <span class="token keyword">super</span><span class="token punctuation">.</span>x <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span> <span class="token comment">// 赋值和读取的操作不一样???</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">super</span><span class="token punctuation">.</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// undefined</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 3</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">let</span> b <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">B</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><h3 id="原型链" tabindex="-1">原型链 <a class="header-anchor" href="#原型链" aria-hidden="true">#</a></h3><p>有以下规律</p><ol><li>子类的 _<em>proto_</em> 属性，表示构造函数的继承，总是指向父类</li><li>子类的 prototype 的 _<em>proto_</em> 属性，表示原型方法的继承，总是指向父类的 prototype 属性</li></ol><div class="language-js"><pre><code><span class="token comment">// 具体的实现流程</span>
<span class="token keyword">class</span> <span class="token class-name">A</span> <span class="token punctuation">{</span>
<span class="token punctuation">}</span>

<span class="token keyword">class</span> <span class="token class-name">B</span> <span class="token keyword">extends</span> <span class="token class-name">A</span><span class="token punctuation">{</span>
<span class="token punctuation">}</span>

<span class="token constant">B</span><span class="token punctuation">.</span>__proto__ <span class="token operator">===</span> <span class="token constant">A</span> <span class="token comment">// true</span>
<span class="token class-name">B</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>__proto__ <span class="token operator">===</span> <span class="token class-name">A</span><span class="token punctuation">.</span>prototype <span class="token comment">// true</span>

<span class="token comment">// B 的实例继承 A 的实例</span>
Object<span class="token punctuation">.</span><span class="token function">setPrototypeOf</span><span class="token punctuation">(</span><span class="token class-name">B</span><span class="token punctuation">.</span>prototype<span class="token punctuation">,</span> <span class="token class-name">A</span><span class="token punctuation">.</span>prototype<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 等价于 B.prototype.__proto__ = A.prototype</span>

<span class="token comment">// B 继承 A 的静态属性</span>
Object<span class="token punctuation">.</span><span class="token function">setPrototypeOf</span><span class="token punctuation">(</span><span class="token constant">B</span><span class="token punctuation">,</span> <span class="token constant">A</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 等价于 B.__proto = A</span>

<span class="token keyword">const</span> b <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">B</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

</code></pre></div><ul><li>实例对象的原型链</li></ul><p>⭐ 面试的时候有问这么一个问题</p><div class="language-js"><pre><code><span class="token keyword">class</span> <span class="token class-name">A</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token keyword">class</span> <span class="token class-name">B</span> <span class="token keyword">extends</span> <span class="token class-name">A</span><span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token keyword">const</span> c <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">B</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token comment">// 请问 c 的原型链是怎么继承的</span>
</code></pre></div><div class="language-js"><pre><code><span class="token keyword">class</span> <span class="token class-name">Point</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token keyword">class</span> <span class="token class-name">ColorPoint</span> <span class="token keyword">extends</span> <span class="token class-name">Point</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>

<span class="token keyword">var</span> p1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Point</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">var</span> p2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ColorPoint</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// 我是这么理解的，Point 和 ColortPoint 都是作为构造函数生成 p1 和 p2</span>
<span class="token comment">// 自然符合 ES5 中的一些规范要求</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>p2<span class="token punctuation">.</span>__proto__ <span class="token operator">===</span> <span class="token class-name">ColorPoint</span><span class="token punctuation">.</span>prototype<span class="token punctuation">)</span>  <span class="token comment">// true</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>p2<span class="token punctuation">.</span>__proto__<span class="token punctuation">.</span>__proto__ <span class="token operator">===</span> <span class="token class-name">Point</span><span class="token punctuation">.</span>prototype<span class="token punctuation">)</span> <span class="token comment">// true </span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">typeof</span> Point<span class="token punctuation">)</span> <span class="token comment">// &#39;function&#39;</span>
</code></pre></div><p>根据上面的一些输出：其实 Point 和 ColorPoint 就是构造函数，所以对于 c 来说，c__proto__ === B.prototype，而 B.prototype === A.prototype，这就是这个问题的答案</p><h3 id="类合并" tabindex="-1">类合并 <a class="header-anchor" href="#类合并" aria-hidden="true">#</a></h3><p>可以抽取出来一个 mix 函数，实现多个类实例属性 / 静态属性的合并</p><div class="language-js"><pre><code><span class="token keyword">function</span> <span class="token function">mix</span><span class="token punctuation">(</span><span class="token parameter"><span class="token operator">...</span>mixins</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">class</span> <span class="token class-name">Mix</span> <span class="token punctuation">{</span>
    <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> mixin <span class="token keyword">of</span> mixins<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">copyProperties</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">mixin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 拷贝实例属性</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>

  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> mixin <span class="token keyword">of</span> mixins<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">copyProperties</span><span class="token punctuation">(</span>Mix<span class="token punctuation">,</span> mixin<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 拷贝静态属性</span>
    <span class="token function">copyProperties</span><span class="token punctuation">(</span><span class="token class-name">Mix</span><span class="token punctuation">.</span>prototype<span class="token punctuation">,</span> mixin<span class="token punctuation">.</span>prototype<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 拷贝原型属性</span>
  <span class="token punctuation">}</span>

  <span class="token keyword">return</span> Mix<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">function</span> <span class="token function">copyProperties</span><span class="token punctuation">(</span><span class="token parameter">target<span class="token punctuation">,</span> source</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> key <span class="token keyword">of</span> Reflect<span class="token punctuation">.</span><span class="token function">ownKeys</span><span class="token punctuation">(</span>source<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span> key <span class="token operator">!==</span> <span class="token string">&#39;constructor&#39;</span>
      <span class="token operator">&amp;&amp;</span> key <span class="token operator">!==</span> <span class="token string">&#39;prototype&#39;</span>
      <span class="token operator">&amp;&amp;</span> key <span class="token operator">!==</span> <span class="token string">&#39;name&#39;</span>
    <span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">let</span> desc <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">getOwnPropertyDescriptor</span><span class="token punctuation">(</span>source<span class="token punctuation">,</span> key<span class="token punctuation">)</span><span class="token punctuation">;</span>
      Object<span class="token punctuation">.</span><span class="token function">defineProperty</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> key<span class="token punctuation">,</span> desc<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token comment">// 具体使用的时候</span>
<span class="token keyword">class</span> <span class="token class-name">A</span> <span class="token keyword">extends</span> <span class="token class-name">mix</span><span class="token punctuation">(</span><span class="token constant">B</span><span class="token punctuation">,</span> <span class="token constant">C</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span> <span class="token comment">// 这样就实现了继承多个类了</span>
</code></pre></div><h2 id="iterator" tabindex="-1">Iterator <a class="header-anchor" href="#iterator" aria-hidden="true">#</a></h2><p>关键词：访问接口；for...of；结构分离</p><p>特性 / 作用</p><ul><li>为不同的数据结构提供了统一的访问形式</li><li>数据结构成员按某种次序排列</li><li>为 for...of 遍历提供接口</li></ul><p>封装数据结构返回一个遍历器对象，初始时遍历器指针指向结构的第一个元素，不断地调用 next 方法，指针不断后移直至 done 为 true 代表当前结构的数据已经被访问完成。</p><div class="language-js"><pre><code><span class="token comment">// 本质上部署了 Iterator 接口其实指的是有 [Symbol.iterator]: function *() {} 这个方法</span>
<span class="token keyword">const</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span>
	<span class="token punctuation">[</span>Symbol<span class="token punctuation">.</span>iterator<span class="token punctuation">]</span><span class="token operator">:</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token punctuation">{</span>
			<span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// 返回一个 next 方法使得指针可以往后迭代</span>
				<span class="token keyword">return</span> <span class="token punctuation">{</span>
                    <span class="token literal-property property">value</span><span class="token operator">:</span> <span class="token string">&#39;&#39;</span><span class="token punctuation">,</span>
                    <span class="token literal-property property">done</span><span class="token operator">:</span> <span class="token boolean">true</span>
                <span class="token punctuation">}</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>🎉 部署了迭代器接口 ----&gt; 返回迭代器对象 ----&gt; 调用 next 方法 -----&gt; 返回数据结构子元素</p><ul><li>迭代器实现链表结构</li></ul><div class="language-js"><pre><code><span class="token keyword">function</span> <span class="token function">Obj</span><span class="token punctuation">(</span><span class="token parameter">value</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>value <span class="token operator">=</span> value<span class="token punctuation">;</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>next <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// 部署接口</span>
<span class="token class-name">Obj</span><span class="token punctuation">.</span>prototype<span class="token punctuation">[</span>Symbol<span class="token punctuation">.</span>iterator<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">var</span> iterator <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token literal-property property">next</span><span class="token operator">:</span> next <span class="token punctuation">}</span><span class="token punctuation">;</span> <span class="token comment">// 返回迭代器对象</span>

  <span class="token keyword">var</span> current <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">;</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>current<span class="token punctuation">)</span>

  <span class="token keyword">function</span> <span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>current<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// 判断 next 指向的是否是 null</span>
      <span class="token keyword">var</span> value <span class="token operator">=</span> current<span class="token punctuation">.</span>value<span class="token punctuation">;</span>
      current <span class="token operator">=</span> current<span class="token punctuation">.</span>next<span class="token punctuation">;</span> <span class="token comment">// 指向下一个指针</span>
      <span class="token keyword">return</span> <span class="token punctuation">{</span> <span class="token literal-property property">done</span><span class="token operator">:</span> <span class="token boolean">false</span><span class="token punctuation">,</span> <span class="token literal-property property">value</span><span class="token operator">:</span> value <span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> <span class="token punctuation">{</span> <span class="token literal-property property">done</span><span class="token operator">:</span> <span class="token boolean">true</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">return</span> iterator<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">var</span> one <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Obj</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">var</span> two <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Obj</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  
<span class="token keyword">var</span> three <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Obj</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
one<span class="token punctuation">.</span>next <span class="token operator">=</span> two<span class="token punctuation">;</span>
two<span class="token punctuation">.</span>next <span class="token operator">=</span> three<span class="token punctuation">;</span>

<span class="token comment">// 做了这么一件事 { value, next: {value, next: {value, next}}  }</span>

<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">var</span> i <span class="token keyword">of</span> one<span class="token punctuation">)</span><span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 1, 2, 3</span>
<span class="token punctuation">}</span>
</code></pre></div><h3 id="部署迭代器接口" tabindex="-1">部署迭代器接口 <a class="header-anchor" href="#部署迭代器接口" aria-hidden="true">#</a></h3><ul><li>对于类数组对象来说，可以直接拷贝 Array.prototype 的迭代器接口</li></ul><p>⚠️ 经过测试，函数的 arguments 列表居然是可以迭代的(可能是内置了)</p><div class="language-js"><pre><code><span class="token keyword">const</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span>
    <span class="token number">0</span><span class="token operator">:</span> <span class="token string">&#39;a&#39;</span><span class="token punctuation">,</span>
    <span class="token number">1</span><span class="token operator">:</span> <span class="token string">&#39;b&#39;</span><span class="token punctuation">,</span>
    <span class="token number">2</span><span class="token operator">:</span> <span class="token string">&#39;c&#39;</span><span class="token punctuation">,</span>
    <span class="token literal-property property">length</span><span class="token operator">:</span> <span class="token number">3</span>
<span class="token punctuation">}</span>
<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">const</span> item <span class="token keyword">of</span> obj<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment">// 正常来说我们是不能通过 for...of 遍历obj的</span>
    <span class="token comment">// 因为 obj 没有部署迭代器接口</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>item<span class="token punctuation">)</span> 
<span class="token punctuation">}</span>

<span class="token comment">// 改成下面这样子就可以了</span>
<span class="token keyword">const</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span>
    <span class="token number">0</span><span class="token operator">:</span> <span class="token string">&#39;a&#39;</span><span class="token punctuation">,</span>
    <span class="token number">1</span><span class="token operator">:</span> <span class="token string">&#39;b&#39;</span><span class="token punctuation">,</span>
    <span class="token number">2</span><span class="token operator">:</span> <span class="token string">&#39;c&#39;</span><span class="token punctuation">,</span>
    <span class="token literal-property property">length</span><span class="token operator">:</span> <span class="token number">3</span><span class="token punctuation">,</span>
    <span class="token punctuation">[</span>Symbol<span class="token punctuation">.</span>iterator<span class="token punctuation">]</span><span class="token operator">:</span> <span class="token class-name">Array</span><span class="token punctuation">.</span>prototype<span class="token punctuation">[</span>Symbol<span class="token punctuation">.</span>iterator<span class="token punctuation">]</span>
<span class="token punctuation">}</span>
</code></pre></div><ul><li>对于普通对象来说，需要根据自己实际的需求来定制迭代器接口</li></ul><h3 id="覆盖默认迭代器" tabindex="-1">覆盖默认迭代器 <a class="header-anchor" href="#覆盖默认迭代器" aria-hidden="true">#</a></h3><ul><li>对于具备迭代器接口的数据结构（字符串 / 数组 / etc），我们可以覆盖原来的迭代器接口，从而在不改变原数据的情况下更改遍历的结果。</li></ul><div class="language-js"><pre><code><span class="token keyword">const</span> arr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span>
arr<span class="token punctuation">[</span>Symbol<span class="token punctuation">.</span>iterator<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment">// 覆盖原来的迭代器</span>
    <span class="token keyword">let</span> _first <span class="token operator">=</span> <span class="token boolean">true</span>
    <span class="token keyword">return</span> <span class="token punctuation">{</span>
        <span class="token function-variable function">next</span><span class="token operator">:</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
           <span class="token keyword">if</span><span class="token punctuation">(</span>_first<span class="token punctuation">)</span> <span class="token punctuation">{</span>
               _first <span class="token operator">=</span> <span class="token boolean">false</span>
                <span class="token keyword">return</span> <span class="token punctuation">{</span>
                    <span class="token literal-property property">value</span><span class="token operator">:</span> <span class="token string">&#39;jzyismylover&#39;</span><span class="token punctuation">,</span>
                    <span class="token literal-property property">done</span><span class="token operator">:</span> <span class="token boolean">false</span>
                <span class="token punctuation">}</span>
           <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
               <span class="token keyword">return</span> <span class="token punctuation">{</span>
                   <span class="token literal-property property">done</span><span class="token operator">:</span> <span class="token boolean">true</span>
               <span class="token punctuation">}</span>
           <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">const</span> item <span class="token keyword">of</span> arr<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>item<span class="token punctuation">)</span>  <span class="token comment">// 只会输出 jzyismylover</span>
<span class="token punctuation">}</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span> <span class="token comment">// 还是原来的[1, 2, 3]</span>
</code></pre></div><h3 id="遍历器对象的-return、throw" tabindex="-1">遍历器对象的 return、throw <a class="header-anchor" href="#遍历器对象的-return、throw" aria-hidden="true">#</a></h3><p>遍历器对象除了有 next 方法，还有 return 和 throw 方法。</p><ul><li>return 主要用于在 for...of 循环中遇到 break / throw error 的时候执行 { done: true } 退出当前迭代状态</li></ul><div class="language-js"><pre><code><span class="token keyword">const</span> a1 <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">]</span>
a1<span class="token punctuation">[</span>Symbol<span class="token punctuation">.</span>iterator<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> len <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>length<span class="token punctuation">,</span> _this <span class="token operator">=</span> <span class="token keyword">this</span>
    <span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span>
    <span class="token keyword">return</span> <span class="token punctuation">{</span><span class="token comment">// 其实数组的 iterator 接口就类似这样部署的</span>
        <span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">if</span><span class="token punctuation">(</span>i <span class="token operator">&lt;</span> len<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                i<span class="token operator">++</span>
                <span class="token keyword">return</span> <span class="token punctuation">{</span>
                    <span class="token literal-property property">value</span><span class="token operator">:</span> _this<span class="token punctuation">[</span>i<span class="token punctuation">]</span>
                <span class="token punctuation">}</span>
            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
                <span class="token keyword">return</span> <span class="token punctuation">{</span>
                    <span class="token literal-property property">done</span><span class="token operator">:</span> <span class="token boolean">true</span>
                <span class="token punctuation">}</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span><span class="token punctuation">,</span>
        <span class="token keyword">return</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// 如果定义了 return 语法就必须返回一个 done: true</span>
            <span class="token comment">// 否则会报错 Iterator result undefined is not an object</span>
            console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&#39;提前退出了&#39;</span><span class="token punctuation">)</span> <span class="token comment">// 在 break 操作后触发</span>
            <span class="token keyword">return</span> <span class="token punctuation">{</span>
                <span class="token literal-property property">done</span><span class="token operator">:</span> <span class="token boolean">true</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">const</span> item <span class="token keyword">of</span> a1<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>item <span class="token operator">%</span> <span class="token number">2</span> <span class="token operator">===</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">break</span>
    <span class="token punctuation">}</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>item<span class="token punctuation">)</span> <span class="token comment">// 3 5</span>
<span class="token punctuation">}</span>
</code></pre></div><h3 id="for-of-1" tabindex="-1">for...of <a class="header-anchor" href="#for-of-1" aria-hidden="true">#</a></h3><p>只要部署了迭代器接口，我们就可以使用 for...of 对数据结构进行访问，也就是说，for...of循环内部调用的是数据结构的 Symbol.iterator 方法。其实上面也有很多使用 for...of 遍历的例子，就不一一列举了，主要还是从里面的一些特例进行分析。</p><ol><li>数组</li></ol><div class="language-js"><pre><code><span class="token keyword">let</span> arr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
arr<span class="token punctuation">.</span>foo <span class="token operator">=</span> <span class="token string">&#39;hello&#39;</span><span class="token punctuation">;</span>

<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token keyword">in</span> arr<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// &quot;0&quot;, &quot;1&quot;, &quot;2&quot;, &quot;foo&quot;</span>
<span class="token punctuation">}</span>

<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token keyword">of</span> arr<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//  &quot;3&quot;, &quot;5&quot;, &quot;7&quot;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>⚠️ 也就是说 for...of 遍历数组的时候只会遍历数字键，非数字键会被跳过。那如果我把 arr.foo 改成 arr[&#39;3&#39;] 会有变化吗？其实是会有的</p><div class="language-js"><pre><code>arr<span class="token punctuation">[</span><span class="token string">&#39;3&#39;</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">&#39;hello&#39;</span><span class="token punctuation">;</span>
<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token keyword">of</span> arr<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//  &quot;3&quot;, &quot;5&quot;, &quot;7&quot;, &quot;hello&quot;</span>
<span class="token punctuation">}</span>
<span class="token comment">// 其实应该是内部做了一个 parseInt / Number 的转化，然后用 isNaN 去判断</span>
</code></pre></div><ol start="2"><li>Map &amp; Set</li></ol><p>Map 和 Set 都可以使用 for...of 进行迭代遍历</p><div class="language-js"><pre><code><span class="token comment">// 区别在于 Set 迭代的是值，Map 迭代的是键和值</span>
<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">const</span> item <span class="token keyword">of</span> Set<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token punctuation">[</span>key<span class="token punctuation">,</span> value<span class="token punctuation">]</span> <span class="token keyword">of</span> Map<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
</code></pre></div><h3 id="for-in" tabindex="-1">for...in <a class="header-anchor" href="#for-in" aria-hidden="true">#</a></h3><p>for...in 的缺陷在于它将所有的键都看成是字符，所以会把我们自定义的一些属性也给遍历出来，但其实这些并不是我们想要的，就像上面举的一个数组例子一样，会把 arr.foo = &#39;hello&#39; 的 foo 也给遍历出来。所以其实 for...in 更适合用于遍历对象，因为对象其实不需要考虑遍历顺序的问题。</p><p>for... of 的引出其实就是为了给开发人员提供一个统一的数据访问接口，解决传统for 循环复杂，forEach 无法中途退出，for...in 冗余属性等等问题。</p><h2 id="async-函数" tabindex="-1">async 函数 <a class="header-anchor" href="#async-函数" aria-hidden="true">#</a></h2><p>async 函数其实是 Generator 生成器的语法糖</p><p>关键字：内置执行器；更好的语义；更广的适应性；返回值是Promise</p><p>⭐ async 函数会返回一个 Promise 对象，状态变化的理解是关键</p><ul><li><p>内部的 return 作为 then 函数接收的参数</p></li><li><p>内部的 throw 直接作为 catch 捕获的参数</p></li><li><p>只有内部的 await 全部执行完或者遇到 return / 报错才会更新返回 Promise 的状态</p></li></ul><p>🔑 非常重要</p><p>内部成功执行完成但无 return ---&gt; Promise.state === &#39;resolve&#39; -----&gt; then 接受 undefined</p><p>内部成功执行完成有 return ---&gt; Promise.state === &#39;resolve&#39; -------&gt; then 接受 return 的值</p><p>内部抛出 ------&gt; Promise.state === &#39;reject&#39; ---------&gt; catch 接受报错</p><div class="language-js"><pre><code><span class="token keyword">async</span> <span class="token keyword">function</span> <span class="token function">getTitle</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">await</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">resolve<span class="token punctuation">,</span> reject</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
      <span class="token function">setTimeout</span><span class="token punctuation">(</span>resolve<span class="token punctuation">,</span> <span class="token number">1000</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span>
  <span class="token keyword">await</span> <span class="token number">2</span>
  <span class="token comment">// return await 2 等同于 return 2</span>
<span class="token punctuation">}</span>
<span class="token function">getTitle</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token parameter">item</span> <span class="token operator">=&gt;</span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&#39;suc &#39;</span><span class="token operator">+</span>item<span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token comment">// suc: undefined / suc: 2</span>
<span class="token punctuation">.</span><span class="token function">catch</span><span class="token punctuation">(</span><span class="token parameter">err</span> <span class="token operator">=&gt;</span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&#39;err &#39;</span><span class="token punctuation">,</span> err<span class="token punctuation">)</span><span class="token punctuation">)</span>
</code></pre></div><div class="language-js"><pre><code><span class="token keyword">async</span> <span class="token keyword">function</span> <span class="token function">getTitle</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">await</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">resolve<span class="token punctuation">,</span> reject</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
      <span class="token function">setTimeout</span><span class="token punctuation">(</span>resolve<span class="token punctuation">,</span> <span class="token number">1000</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span>
  <span class="token keyword">await</span> <span class="token number">2</span>
  consoo
<span class="token punctuation">}</span>
<span class="token function">getTitle</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token parameter">item</span> <span class="token operator">=&gt;</span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&#39;suc &#39;</span><span class="token operator">+</span>item<span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token punctuation">.</span><span class="token function">catch</span><span class="token punctuation">(</span><span class="token parameter">err</span> <span class="token operator">=&gt;</span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&#39;err &#39;</span><span class="token punctuation">,</span> err<span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token comment">// err: ReferenceError: consoo is not defined</span>
</code></pre></div><p>🔑 面试中遇到的代码考核题</p><div class="language-js"><pre><code><span class="token keyword">async</span> <span class="token keyword">function</span> <span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&#39;async start&#39;</span><span class="token punctuation">)</span>
  <span class="token keyword">await</span> <span class="token string">&#39;tesing&#39;</span> <span class="token comment">// 同样会被注册为微任务 -- 只是说马上就会进行相关状态变化</span>
  <span class="token keyword">await</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">resovle</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&#39;haha&#39;</span><span class="token punctuation">)</span>
    <span class="token function">resovle</span><span class="token punctuation">(</span><span class="token string">&#39;hello world&#39;</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span>
  <span class="token keyword">return</span> <span class="token string">&#39;testing&#39;</span>
<span class="token punctuation">}</span>

console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&#39;script start&#39;</span><span class="token punctuation">)</span>
<span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token parameter">res</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>res<span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&#39;script end&#39;</span><span class="token punctuation">)</span>

<span class="token comment">// await &#39;testing&#39; 我们可以这样去看</span>
<span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">resolve</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token function">resolve</span><span class="token punctuation">(</span><span class="token string">&#39;testing&#39;</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token comment">// 执行后面的代码</span>
    <span class="token comment">// 也就说说后面的代码都会被注册为微任务</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre></div><h3 id="await" tabindex="-1">await <a class="header-anchor" href="#await" aria-hidden="true">#</a></h3><p>await 后面可以分为两种情况：部署了 then 方法 和 没有部署 then 方法</p><ol><li>没有部署 then 方法</li></ol><div class="language-js"><pre><code><span class="token keyword">await</span> <span class="token number">1</span>
<span class="token keyword">await</span> <span class="token string">&#39;hello&#39;</span>
</code></pre></div><p>上面这些会直接注册微任务将参数传递进入 then 中</p><ol start="2"><li>部署了 then 方法（定义了 then 方法的对象）</li></ol><div class="language-js"><pre><code><span class="token keyword">class</span> <span class="token class-name">Sleep</span> <span class="token punctuation">{</span>
  <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token parameter">timeout</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>timeout <span class="token operator">=</span> timeout<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token function">then</span><span class="token punctuation">(</span><span class="token parameter">resolve<span class="token punctuation">,</span> reject</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> startTime <span class="token operator">=</span> Date<span class="token punctuation">.</span><span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">setTimeout</span><span class="token punctuation">(</span>
      <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token function">resolve</span><span class="token punctuation">(</span>Date<span class="token punctuation">.</span><span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> startTime<span class="token punctuation">)</span><span class="token punctuation">,</span>
      <span class="token keyword">this</span><span class="token punctuation">.</span>timeout
    <span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token punctuation">(</span><span class="token keyword">async</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> sleepTime <span class="token operator">=</span> <span class="token keyword">await</span> <span class="token keyword">new</span> <span class="token class-name">Sleep</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 等待 then 方法执行完成</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>sleepTime<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 1000</span>
</code></pre></div><p>如果是上面这种情况的话会执行 promise 的同步代码，然后跳出当前执行函数，等到执行时机回到函数后再将对应的微任务进行注册。</p><div class="language-js"><pre><code><span class="token keyword">function</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token parameter">delay</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">resolve<span class="token punctuation">,</span> reject</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
        <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
            <span class="token function">resolve</span><span class="token punctuation">(</span><span class="token number">111</span><span class="token punctuation">)</span>
        <span class="token punctuation">}</span><span class="token punctuation">,</span> delay<span class="token punctuation">)</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">res</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token string">&#39;thenable&#39;</span> <span class="token operator">+</span> res<span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token punctuation">(</span><span class="token keyword">async</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> res <span class="token operator">=</span> <span class="token keyword">await</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token number">3000</span><span class="token punctuation">)</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>res<span class="token punctuation">)</span>  <span class="token comment">// thenable res</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>本质上的原因是因为 then 返回的也是 promise，所以 await 也会等待 then 返回的 Promise 状态变换后再往上执行，这也是为什么部署了 then 方法的对象会被视为 Promise 对象。总结来说就是 await 返回的结果是最后一个 Promise 处理成功的结果。</p><p>⚠️ 为什么 async 不能用在 forEach 中呢？</p><div class="language-js"><pre><code>arr<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token keyword">async</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token keyword">await</span> <span class="token operator">...</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span> <span class="token comment">// 这样子的方式 arr 中的元素会同时触发也就是不会按顺序返回对应的结果</span>
</code></pre></div><h3 id="错误处理" tabindex="-1">错误处理 <a class="header-anchor" href="#错误处理" aria-hidden="true">#</a></h3><div class="language-js"><pre><code><span class="token keyword">async</span> <span class="token keyword">function</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">try</span> <span class="token punctuation">{</span>
    <span class="token keyword">await</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">resolve<span class="token punctuation">,</span> reject</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">Error</span><span class="token punctuation">(</span><span class="token string">&#39;出错了&#39;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span> <span class="token keyword">catch</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment">// 进行 try...catch 捕获</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">return</span> <span class="token keyword">await</span><span class="token punctuation">(</span><span class="token string">&#39;hello world&#39;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// 或者使用 then 捕获</span>

<span class="token keyword">async</span> <span class="token keyword">function</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">await</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">resolve<span class="token punctuation">,</span> reject</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">Error</span><span class="token punctuation">(</span><span class="token string">&#39;出错了&#39;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">catch</span><span class="token punctuation">(</span>console<span class="token punctuation">.</span>log<span class="token punctuation">)</span>
  <span class="token keyword">return</span> <span class="token keyword">await</span><span class="token punctuation">(</span><span class="token string">&#39;hello world&#39;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><h3 id="内部实现" tabindex="-1">内部实现 <a class="header-anchor" href="#内部实现" aria-hidden="true">#</a></h3><p>运行流程</p><ol><li>执行生成器函数返回生成器对象</li><li>调用 step 方法执行 next</li><li>通过 done: true / false 判断当前是否结束</li><li>结束的话直接返回对应的 value</li><li>否则根据 Promise 的状态：resolve 执行下一个 next 方法 / reject 执行 throw 方法</li></ol><div class="language-js"><pre><code><span class="token keyword">function</span> <span class="token function">fn</span><span class="token punctuation">(</span><span class="token parameter">args</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token function">spawn</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token operator">*</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// ...</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">function</span> <span class="token function">spawn</span><span class="token punctuation">(</span><span class="token parameter">genF</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">resolve<span class="token punctuation">,</span> reject</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">const</span> gen <span class="token operator">=</span> <span class="token function">genF</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// 生成生成器对象</span>
        <span class="token keyword">function</span> <span class="token function">step</span><span class="token punctuation">(</span><span class="token parameter">nextF</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment">// 部署自动执行 Generator</span>
            <span class="token keyword">let</span> next
            <span class="token keyword">try</span> <span class="token punctuation">{</span> <span class="token comment">// 需要注意对应 try...catch 的捕获时机</span>
                <span class="token comment">// 其实只需要捕获 next = nextF()即可</span>
                <span class="token comment">// 因为这里执行可能 generator.throw</span>
                next <span class="token operator">=</span> <span class="token function">nextF</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
                console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>next<span class="token punctuation">)</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span>next<span class="token punctuation">.</span>done<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment">// 执行完成</span>
                    <span class="token keyword">return</span> <span class="token function">resolve</span><span class="token punctuation">(</span>next<span class="token punctuation">.</span>value<span class="token punctuation">)</span>
                <span class="token punctuation">}</span>
                <span class="token comment">// 还可以往下执行的意思</span>
                Promise<span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">(</span>next<span class="token punctuation">.</span>value<span class="token punctuation">)</span>
                    <span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token parameter">val</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span> <span class="token function">step</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> gen<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span>val<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">}</span><span class="token punctuation">)</span>
                    <span class="token punctuation">.</span><span class="token function">catch</span><span class="token punctuation">(</span><span class="token parameter">err</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span> <span class="token function">step</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> gen<span class="token punctuation">.</span><span class="token function">throw</span><span class="token punctuation">(</span>err<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">}</span><span class="token punctuation">)</span>
            <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span>err<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token function">reject</span><span class="token punctuation">(</span>err<span class="token punctuation">)</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
        <span class="token function">step</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> gen<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><h2 id="modules" tabindex="-1">Modules <a class="header-anchor" href="#modules" aria-hidden="true">#</a></h2><p>⭐ ES6 模块设计思想是尽量静态化，静态化的意思就是使得在编译阶段就能确定模块的依赖关系以及输入输出变量。</p><div class="language-js"><pre><code><span class="token comment">// 以前使用 require 导入的时候</span>
<span class="token keyword">const</span> <span class="token punctuation">{</span> resolve <span class="token punctuation">}</span> <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">&#39;fs&#39;</span><span class="token punctuation">)</span>

<span class="token comment">/* 本质上等价于 */</span>
<span class="token keyword">const</span> fs <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">&#39;fs&#39;</span><span class="token punctuation">)</span>
resolve <span class="token operator">=</span> fs<span class="token punctuation">.</span>resolve
</code></pre></div><p>❗ 也就是说 CommonJS 导出的其实是一个模块对象，然后再从对象上读取方法进行赋值，所以只有运行的时候我们才知道加载了哪些方法，没有办法在编译阶段进行判断。</p><p>而 ES6 使用 import / export 关键字，本质上导出的不是一个模块对象，而是表达加载的含义</p><div class="language-js"><pre><code><span class="token comment">// 从 fs 上加载三个属性/方法</span>
<span class="token keyword">import</span> <span class="token punctuation">{</span> stat<span class="token punctuation">,</span> exists<span class="token punctuation">,</span> readFile <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">&#39;fs&#39;</span>
</code></pre></div><h3 id="export" tabindex="-1">export <a class="header-anchor" href="#export" aria-hidden="true">#</a></h3><p>🔑 export 向外导出的是一个接口</p><div class="language-js"><pre><code><span class="token keyword">function</span> <span class="token function">v1</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token operator">...</span> <span class="token punctuation">}</span>
<span class="token keyword">function</span> <span class="token function">v2</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token operator">...</span> <span class="token punctuation">}</span>

<span class="token comment">// 推荐使用这种方式进行导出</span>
<span class="token comment">// 因为我们一眼就能看到导出了啥</span>
<span class="token keyword">export</span> <span class="token punctuation">{</span>
  v1 <span class="token keyword">as</span> streamV1<span class="token punctuation">,</span> <span class="token comment">// 使用 as 关键字进行导出模块的重命名</span>
  v2 <span class="token keyword">as</span> streamV2<span class="token punctuation">,</span>
  v2 <span class="token keyword">as</span> streamLatestVersion
<span class="token punctuation">}</span><span class="token punctuation">;</span>
               
<span class="token keyword">export</span> <span class="token number">1</span>  <span class="token comment">// Error：导出的是接口不是值</span>
</code></pre></div><h3 id="import" tabindex="-1">import <a class="header-anchor" href="#import" aria-hidden="true">#</a></h3><p>🔑 import 导入的是 export 的接口，所以对应的属性最好不要修改，也就是 read-only 就好。和 export 一样，import 同样存在作用域提升，默认提升到当前全局作用域的顶部。</p><div class="language-js"><pre><code><span class="token keyword">import</span> <span class="token punctuation">{</span> streamV1 <span class="token keyword">as</span> stream<span class="token punctuation">,</span> streamV2 <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">&#39;./test.js&#39;</span>
<span class="token comment">// 导入的名字必须与 export 相同</span>
<span class="token comment">// 可以使用 as 关键字进行重命名</span>

<span class="token keyword">import</span> <span class="token punctuation">{</span> <span class="token string">&#39;foo&#39;</span> <span class="token operator">+</span> a <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">&#39;./test.js&#39;</span>
<span class="token comment">// Error：因为静态编译的原因不允许通过表达式去引入</span>

<span class="token keyword">import</span> <span class="token operator">*</span> <span class="token keyword">as</span> moduleName <span class="token keyword">from</span> <span class="token string">&#39;./test.js&#39;</span> <span class="token comment">// 模块整体导出重命名为 moduleName</span>
moduleName<span class="token punctuation">.</span><span class="token function">getNaem</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// 通过类似这样的方式来实现调用</span>
</code></pre></div><h3 id="export-default" tabindex="-1">export default <a class="header-anchor" href="#export-default" aria-hidden="true">#</a></h3><div class="language-js"><pre><code><span class="token keyword">export</span> <span class="token keyword">default</span> a

<span class="token comment">/* 等价于 */</span>

<span class="token keyword">export</span> <span class="token punctuation">{</span>
	a <span class="token keyword">as</span> <span class="token keyword">default</span>
<span class="token punctuation">}</span>
</code></pre></div><p>🔑 因此一个模块内部只能使用一次 export default, 多次使用就不知道把那个变量命名为default 导出。export default 其实是 export 的特殊情况，以 default 作为默认接口导出</p><div class="language-js"><pre><code><span class="token comment">/* 导出 */</span>
<span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">obj</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// ···</span>
<span class="token punctuation">}</span>

<span class="token keyword">export</span> <span class="token keyword">function</span> <span class="token function">each</span><span class="token punctuation">(</span><span class="token parameter">obj<span class="token punctuation">,</span> iterator<span class="token punctuation">,</span> context</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// ···</span>
<span class="token punctuation">}</span>

<span class="token keyword">export</span> <span class="token punctuation">{</span> each <span class="token keyword">as</span> forEach <span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token comment">/* 导入 */</span>
<span class="token keyword">import</span> _<span class="token punctuation">,</span> <span class="token punctuation">{</span> each<span class="token punctuation">,</span> forEach <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">&#39;lodash&#39;</span><span class="token punctuation">;</span>
</code></pre></div><p>上面是很多包模块比较常见的写法 -- 同时接受 default 接口和其他接口的导出。</p><p>❣️ !!! 以下概念 在 vite 的模块导出(i<strong>mport.meta.globEager</strong>)非常重要</p><div class="language-js"><pre><code><span class="token comment">// index.js</span>
<span class="token keyword">export</span> <span class="token keyword">const</span> a <span class="token operator">=</span> <span class="token number">1</span>
<span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">{</span>
  <span class="token literal-property property">name</span><span class="token operator">:</span> <span class="token string">&#39;jzyismylover&#39;</span>
<span class="token punctuation">}</span>

<span class="token comment">// main.js 导入</span>
<span class="token keyword">import</span> <span class="token operator">*</span> <span class="token keyword">as</span> module <span class="token keyword">from</span> <span class="token string">&#39;./index.js&#39;</span>
<span class="token comment">/*
{
	a: 1,
	default: { name: &#39;jzyismylover&#39; }
}
*/</span>
</code></pre></div><p>本质上其实是 export default 导出 default 接口 和 a接口，但是写在一起的话不是那么容易去理解</p><h3 id="export-import-复合写法" tabindex="-1">export &amp; import 复合写法 <a class="header-anchor" href="#export-import-复合写法" aria-hidden="true">#</a></h3><div class="language-js"><pre><code><span class="token keyword">export</span> <span class="token punctuation">{</span> <span class="token keyword">for</span><span class="token punctuation">,</span> bar <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">&#39;module&#39;</span>

<span class="token comment">/* 等价于 */</span>
<span class="token keyword">import</span> <span class="token punctuation">{</span> foo<span class="token punctuation">,</span> bar <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">&#39;module&#39;</span>
<span class="token keyword">export</span> <span class="token punctuation">{</span>
	foo<span class="token punctuation">,</span>
    bar
<span class="token punctuation">}</span>
</code></pre></div><div class="language-js"><pre><code><span class="token keyword">export</span> <span class="token punctuation">{</span> foo <span class="token keyword">as</span> <span class="token keyword">default</span> <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">&#39;module&#39;</span>

<span class="token comment">/* 等价于 */</span>
<span class="token keyword">import</span> <span class="token punctuation">{</span> foo <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">&#39;module&#39;</span>
<span class="token keyword">export</span> <span class="token keyword">default</span> foo
</code></pre></div><div class="language-js"><pre><code><span class="token keyword">export</span> <span class="token punctuation">{</span> <span class="token keyword">default</span> <span class="token keyword">as</span> foo <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">&#39;module&#39;</span>

<span class="token comment">/* 等价于 */</span>
<span class="token keyword">import</span> foo <span class="token keyword">from</span> <span class="token string">&#39;module&#39;</span>
<span class="token keyword">export</span> <span class="token punctuation">{</span>
	foo
<span class="token punctuation">}</span>
</code></pre></div><p>❗ 使用上面复合的写法的话内部是无法使用导入的变量，这点需要注意！！！</p><h3 id="跨模块常量" tabindex="-1">跨模块常量 <a class="header-anchor" href="#跨模块常量" aria-hidden="true">#</a></h3><p>！！！如果在项目中使用到很多的常量，比如说路由，接口名，菜单名等等，ES6 里面推荐我们建一个 constants 的文件夹来存储这些常量，并将不同模块的常量抽取到 index.js 中，最后需要导入的时候从 index.js 里面导入即可。</p><div class="language-js"><pre><code><span class="token comment">// constants/menu.js</span>
<span class="token keyword">export</span> <span class="token keyword">const</span> menu <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token punctuation">}</span>

<span class="token comment">// constants/route.js</span>
<span class="token keyword">export</span> <span class="token keyword">const</span> routes <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token punctuation">}</span>

<span class="token comment">// constants/index.js</span>
<span class="token keyword">export</span> <span class="token punctuation">{</span> menu <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">&#39;./menu.js&#39;</span>
<span class="token keyword">export</span> <span class="token punctuation">{</span> routes <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">&#39;./route.js&#39;</span> 

<span class="token comment">// 外部使用的时候</span>
<span class="token keyword">import</span> <span class="token punctuation">{</span> menu <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">&#39;constants/index.js&#39;</span>
</code></pre></div><h3 id="import-1" tabindex="-1">import() <a class="header-anchor" href="#import-1" aria-hidden="true">#</a></h3><p>🔑 是 ES2020 提出的运行时加载的手段，返回一个 promise. 在 Vue 中懒加载路由有运用到</p><div class="language-js"><pre><code><span class="token comment">// index.js</span>
<span class="token keyword">export</span> <span class="token keyword">const</span> a <span class="token operator">=</span> <span class="token number">1</span>
<span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">{</span>
  <span class="token literal-property property">name</span><span class="token operator">:</span> <span class="token string">&#39;jzyismylover&#39;</span>
<span class="token punctuation">}</span>

<span class="token keyword">import</span><span class="token punctuation">(</span><span class="token string">&#39;./index&#39;</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token parameter">module</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>module<span class="token punctuation">)</span> <span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token comment">/*
module: {
	a: &#39;1&#39;,
	default: { name: &#39;jzyismylover&#39; }
}
*/</span>
<span class="token comment">//---------------------------------</span>
<span class="token comment">/*
仅有 export default 的情况
module: {
	default: { name: &#39;jzyismylover&#39; }
}
*/</span>
<span class="token comment">//----------------------------------</span>
<span class="token comment">/*
仅有 export 的情况
module: {
	a: 1
}
*/</span>
</code></pre></div></div></div><footer class="page-footer" data-v-7eddb2c4 data-v-07c132fc><div class="edit" data-v-07c132fc><div class="edit-link" data-v-07c132fc data-v-1ed99556><!----></div></div><div class="updated" data-v-07c132fc><!----></div></footer><div class="next-and-prev-link" data-v-7eddb2c4 data-v-38ede35f><div class="container" data-v-38ede35f><div class="prev" data-v-38ede35f><!----></div><div class="next" data-v-38ede35f><a class="link" href="/yl/yl/" data-v-38ede35f><span class="text" data-v-38ede35f>vue</span><svg xmlns="http://www.w3.org/2000/svg" viewbox="0 0 24 24" class="icon icon-next" data-v-38ede35f><path d="M19.9,12.4c0.1-0.2,0.1-0.5,0-0.8c-0.1-0.1-0.1-0.2-0.2-0.3l-7-7c-0.4-0.4-1-0.4-1.4,0s-0.4,1,0,1.4l5.3,5.3H5c-0.6,0-1,0.4-1,1s0.4,1,1,1h11.6l-5.3,5.3c-0.4,0.4-0.4,1,0,1.4c0.2,0.2,0.5,0.3,0.7,0.3s0.5-0.1,0.7-0.3l7-7C19.8,12.6,19.9,12.5,19.9,12.4z"></path></svg></a></div></div></div><!--[--><!--]--></div></main></div><!----><!--]--></div>
    <script>__VP_HASH_MAP__ = JSON.parse("{\"index.md\":\"1cd71748\",\"yl_index.md\":\"9535c5af\",\"yl_learning.md\":\"d3490df1\"}")</script>
    <script type="module" async src="/yl/assets/app.a8623452.js"></script>
    
  </body>
</html>